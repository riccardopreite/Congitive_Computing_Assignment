<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ccbase.nodes API documentation</title>
<meta name="description" content="Created on Tue Nov 24 16:14:30 2020
Refactored module, holding different kinds of graph nodes. Our basic graph
node from before will be used as …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ccbase.nodes</code></h1>
</header>
<section id="section-intro">
<p>Created on Tue Nov 24 16:14:30 2020
Refactored module, holding different kinds of graph nodes. Our basic graph
node from before will be used as baseclass for other extensions.</p>
<p>@author: jpoeppel</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-
&#34;&#34;&#34;
Created on Tue Nov 24 16:14:30 2020
Refactored module, holding different kinds of graph nodes. Our basic graph
node from before will be used as baseclass for other extensions.

@author: jpoeppel
&#34;&#34;&#34;
from __future__ import annotations
import numpy as np

from typing import Optional, List, Dict, Iterable

class Node:
    &#34;&#34;&#34;
        Base class for nodes within a graph.

        Attributes
        ----------
        name: String
            The name or identifier of the node
        parents: dict
            A dictionary containing parent-name:Node pairs for all parents of this node
        children: dict
            A dictionary containing child-name:Node pairs for children of this node

    &#34;&#34;&#34;
    
    def __init__(self, name: str):
        self.name = name
        self.parents = {}
        self.children = {}
        
    def add_parent(self, parent: Node):
        &#34;&#34;&#34;
            Add or overwrites a parent node. Will not check if there already is
            a parent with the same name.
            
            Parameters
            ----------
            parent: Node
                The node to be added as parent.
        &#34;&#34;&#34;
        self.parents[parent.name] = parent
        
    def add_child(self, child: Node):
        &#34;&#34;&#34;
            Add or overwrites a child node. Will not check if there already is
            a child with the same name.
            
            Parameters
            ----------
            child: Node
                The node to be added as child.
        &#34;&#34;&#34;
        self.children[child.name] = child
        
    def remove_parent(self, parent: Node):
        &#34;&#34;&#34;
            Removes a parent node if it exists. If it did not exist, will do 
            nothing.
            
            Parameters
            ----------
            parent: Node
                The node to be removed as parent.
        &#34;&#34;&#34;
        
        if parent.name in self.parents:
            del self.parents[parent.name]
            
    def remove_child(self, child: Node):
        &#34;&#34;&#34;
            Removes a child node if it exists. If it did not exist, will do 
            nothing.
            
            Parameters
            ----------
            child: Node
                The node to be removed as child.
        &#34;&#34;&#34;
        if child.name in self.children:
            del self.children[child.name]
        
    def destroy(self):
        &#34;&#34;&#34;
            &#34;Destroys&#34; the node by removing its link to all its neighbours.
            This will **not** destroy the actual node object. This would have
            to be taken care of elsewhere.
        &#34;&#34;&#34;
        for p in self.parents.values():
            p.remove_child(self)
        
        for c in self.children.values():
            c.remove_parent(self)
        self.parents = {}
        self.children = {}
        
    def __hash__(self) -&gt; str:
        &#34;&#34;&#34;
            The hash of a node is the same as the hash of its name.
            This allows to reference nodes in dictionaries by their object
            instantiation or their name.
        &#34;&#34;&#34;
        return hash(self.name)
        
    def __str__(self) -&gt; str:
        &#34;&#34;&#34;
            Overwrites the default string representation of this class to just
            return it&#39;s name.
        &#34;&#34;&#34;
        return self.name
    
    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;
            Overwrites the default string representation of this class to just
            return it&#39;s name.
        &#34;&#34;&#34;
        return self.name
    
    def __eq__(self, other: Node) -&gt; bool:
        &#34;&#34;&#34;
            Two nodes are considered to be identical if they have the
            same name.
            In order for the access in dictionaries via the name to work, a
            random node is equal to its name as well.
        &#34;&#34;&#34;
        try:
            return other.name == self.name
        except AttributeError:
            return other == self.name
        
    def __ne__(self, other: Node) -&gt; bool:
        &#34;&#34;&#34;
            Checking if the given node is NOT equal to the current instance.
        &#34;&#34;&#34;
        return not self.__eq__(other)
    
    
    
class DiscreteVariable(Node):
    &#34;&#34;&#34;
        The extension of our classical graph node to represent discrete
        variables in Bayesian networks.
    &#34;&#34;&#34;

    def __init__(self, name: str, outcomes: List[str], cpt: Optional[np.array] = None):
        super(DiscreteVariable, self).__init__(name)
        # In order to not rely on the parents dict to keep the order of the 
        # parents (which was not the case prior to Python3.6) we use an 
        # additional list to keep track of the parent order.
        self.parent_order = [] 
        
        # CPTs will be stored semi-compactly as an multidimensional array
        # using the first dimension for the outcomes of the variable itself,
        # and the following dimensions for this variable&#39;s parents.
        if cpt is not None:
            self.cpt = cpt
        else:
            self.cpt = 0
        self.outcomes = outcomes
        
    def add_parent(self, parent_node: DiscreteVariable):
        &#34;&#34;&#34;
            Add the given parent node from this node&#39;s
            parents. Uses the DiscreteVariable function while
            making sure to update the parent_order as well.

            Parameter
            ---------
            parent_node: DiscreteVariable
                The DiscreteVariable to that is to be added as a parent.
        &#34;&#34;&#34;
        self.parent_order.append(parent_node.name)
        super(DiscreteVariable,self).add_parent(parent_node)

    def remove_parent(self, parent_node: DiscreteVariable):
        &#34;&#34;&#34;
            Removes the given parent node from this node&#39;s
            parents. Uses the DiscreteVariable function while
            making sure to update the parent_order as well.

            Parameter
            ---------
            parent_node: DiscreteVariable
                The DiscreteVariable to that is to be removed as a parent.
        &#34;&#34;&#34;
        if parent_node.name in self.parent_order:
            self.parent_order.remove(parent_node.name)
        super(DiscreteVariable,self).remove_parent(parent_node)
        
    def set_probability_table(self, table: Iterable):
        &#34;&#34;&#34;
            Allows to set the conditional probability density(table) of this
            node directly. Will check that the dimensions of the given cpd
            is conform to the current dependency structure but will not perform
            any tests on the actual values.
            
            Parameters
            ----------
            cpd : iterable
                Table containing the conditional probabilities. Each variable 
                is represented by a dimension in the size of the number of its
                outcomes.
        &#34;&#34;&#34;
        
        # Check what dimensions the cpt would need to have given the current
        # parent structure of this node
        dimensions = [len(self.outcomes)]
        for parent_name in self.parent_order:
            dimensions.append(len(self.parents[parent_name].outcomes))
        #Make sure table is a numpy array and create copy.
        npTable = np.array(table)
        if npTable.shape != tuple(dimensions):
            raise ValueError(&#34;The dimensions of the given cpd do not match &#34; + \
                             &#34;the dependency structure of the node.&#34;)
        # Set the table
        self.cpt = npTable
        
    def get_distribution(self, evidence: Optional[Dict] = None) -&gt; dict:
        &#34;&#34;&#34;
            Returns the distribution in the form of a dictionary 
            (outcome:probability) for the this variable. 
            Uses a similar method as the factor.potential function.
            
            Parameter
            --------
            evidence: dict (optional)
                A dictionary containing variable:outcome pairs specifying
                the evidental state of the parent nodes.
                
            Returns
            -------
            dict
                A dictionary containing the outcomes of this variable as keys
                and their corresponding (conditional) probabilities given
                the evidence if present.
        &#34;&#34;&#34;
        #Construct the index for the desired potential
        index = [list(range(len(self.outcomes)))]
        for p in self.parent_order:
            if p in evidence:
                try:
                    index.append([self.parents[p].outcomes.index(evidence[p])])
                except ValueError:
                    raise ValueError(&#34;The parent {} does not have the outcome &#34; + \
                                     &#34;{}&#34;.format(p, evidence[p]))
            else:
                raise ValueError(&#34;In order to get a distribution for this &#34; + \
                                 &#34;variable, all it&#39;s parents need to be specified &#34; + \
                                 &#34;as evidence, but {} was not specified.&#34;.format(p))
                    
        #np.ix_ constructs an access mask which allows efficient access
        #to the desired cells. This approach allows underspecification of the
        #instantiation (i.e. not all variables are specified) which will
        #result in returning a matrix for the remaining variables
        probs = np.squeeze(self.cpt[np.ix_(*index)])
        return {outcome: probs[i] for i,outcome in enumerate(self.outcomes)}
        </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ccbase.nodes.DiscreteVariable"><code class="flex name class">
<span>class <span class="ident">DiscreteVariable</span></span>
<span>(</span><span>name: str, outcomes: List[str], cpt: Optional[np.array] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>The extension of our classical graph node to represent discrete
variables in Bayesian networks.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DiscreteVariable(Node):
    &#34;&#34;&#34;
        The extension of our classical graph node to represent discrete
        variables in Bayesian networks.
    &#34;&#34;&#34;

    def __init__(self, name: str, outcomes: List[str], cpt: Optional[np.array] = None):
        super(DiscreteVariable, self).__init__(name)
        # In order to not rely on the parents dict to keep the order of the 
        # parents (which was not the case prior to Python3.6) we use an 
        # additional list to keep track of the parent order.
        self.parent_order = [] 
        
        # CPTs will be stored semi-compactly as an multidimensional array
        # using the first dimension for the outcomes of the variable itself,
        # and the following dimensions for this variable&#39;s parents.
        if cpt is not None:
            self.cpt = cpt
        else:
            self.cpt = 0
        self.outcomes = outcomes
        
    def add_parent(self, parent_node: DiscreteVariable):
        &#34;&#34;&#34;
            Add the given parent node from this node&#39;s
            parents. Uses the DiscreteVariable function while
            making sure to update the parent_order as well.

            Parameter
            ---------
            parent_node: DiscreteVariable
                The DiscreteVariable to that is to be added as a parent.
        &#34;&#34;&#34;
        self.parent_order.append(parent_node.name)
        super(DiscreteVariable,self).add_parent(parent_node)

    def remove_parent(self, parent_node: DiscreteVariable):
        &#34;&#34;&#34;
            Removes the given parent node from this node&#39;s
            parents. Uses the DiscreteVariable function while
            making sure to update the parent_order as well.

            Parameter
            ---------
            parent_node: DiscreteVariable
                The DiscreteVariable to that is to be removed as a parent.
        &#34;&#34;&#34;
        if parent_node.name in self.parent_order:
            self.parent_order.remove(parent_node.name)
        super(DiscreteVariable,self).remove_parent(parent_node)
        
    def set_probability_table(self, table: Iterable):
        &#34;&#34;&#34;
            Allows to set the conditional probability density(table) of this
            node directly. Will check that the dimensions of the given cpd
            is conform to the current dependency structure but will not perform
            any tests on the actual values.
            
            Parameters
            ----------
            cpd : iterable
                Table containing the conditional probabilities. Each variable 
                is represented by a dimension in the size of the number of its
                outcomes.
        &#34;&#34;&#34;
        
        # Check what dimensions the cpt would need to have given the current
        # parent structure of this node
        dimensions = [len(self.outcomes)]
        for parent_name in self.parent_order:
            dimensions.append(len(self.parents[parent_name].outcomes))
        #Make sure table is a numpy array and create copy.
        npTable = np.array(table)
        if npTable.shape != tuple(dimensions):
            raise ValueError(&#34;The dimensions of the given cpd do not match &#34; + \
                             &#34;the dependency structure of the node.&#34;)
        # Set the table
        self.cpt = npTable
        
    def get_distribution(self, evidence: Optional[Dict] = None) -&gt; dict:
        &#34;&#34;&#34;
            Returns the distribution in the form of a dictionary 
            (outcome:probability) for the this variable. 
            Uses a similar method as the factor.potential function.
            
            Parameter
            --------
            evidence: dict (optional)
                A dictionary containing variable:outcome pairs specifying
                the evidental state of the parent nodes.
                
            Returns
            -------
            dict
                A dictionary containing the outcomes of this variable as keys
                and their corresponding (conditional) probabilities given
                the evidence if present.
        &#34;&#34;&#34;
        #Construct the index for the desired potential
        index = [list(range(len(self.outcomes)))]
        for p in self.parent_order:
            if p in evidence:
                try:
                    index.append([self.parents[p].outcomes.index(evidence[p])])
                except ValueError:
                    raise ValueError(&#34;The parent {} does not have the outcome &#34; + \
                                     &#34;{}&#34;.format(p, evidence[p]))
            else:
                raise ValueError(&#34;In order to get a distribution for this &#34; + \
                                 &#34;variable, all it&#39;s parents need to be specified &#34; + \
                                 &#34;as evidence, but {} was not specified.&#34;.format(p))
                    
        #np.ix_ constructs an access mask which allows efficient access
        #to the desired cells. This approach allows underspecification of the
        #instantiation (i.e. not all variables are specified) which will
        #result in returning a matrix for the remaining variables
        probs = np.squeeze(self.cpt[np.ix_(*index)])
        return {outcome: probs[i] for i,outcome in enumerate(self.outcomes)}</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ccbase.nodes.Node" href="#ccbase.nodes.Node">Node</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ccbase.nodes.DiscreteVariable.add_parent"><code class="name flex">
<span>def <span class="ident">add_parent</span></span>(<span>self, parent_node: <a title="ccbase.nodes.DiscreteVariable" href="#ccbase.nodes.DiscreteVariable">DiscreteVariable</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Add the given parent node from this node's
parents. Uses the DiscreteVariable function while
making sure to update the parent_order as well.</p>
<h2 id="parameter">Parameter</h2>
<p>parent_node: DiscreteVariable
The DiscreteVariable to that is to be added as a parent.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_parent(self, parent_node: DiscreteVariable):
    &#34;&#34;&#34;
        Add the given parent node from this node&#39;s
        parents. Uses the DiscreteVariable function while
        making sure to update the parent_order as well.

        Parameter
        ---------
        parent_node: DiscreteVariable
            The DiscreteVariable to that is to be added as a parent.
    &#34;&#34;&#34;
    self.parent_order.append(parent_node.name)
    super(DiscreteVariable,self).add_parent(parent_node)</code></pre>
</details>
</dd>
<dt id="ccbase.nodes.DiscreteVariable.get_distribution"><code class="name flex">
<span>def <span class="ident">get_distribution</span></span>(<span>self, evidence: Optional[Dict] = None) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the distribution in the form of a dictionary
(outcome:probability) for the this variable.
Uses a similar method as the factor.potential function.</p>
<h2 id="parameter">Parameter</h2>
<p>evidence: dict (optional)
A dictionary containing variable:outcome pairs specifying
the evidental state of the parent nodes.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary containing the outcomes of this variable as keys
and their corresponding (conditional) probabilities given
the evidence if present.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_distribution(self, evidence: Optional[Dict] = None) -&gt; dict:
    &#34;&#34;&#34;
        Returns the distribution in the form of a dictionary 
        (outcome:probability) for the this variable. 
        Uses a similar method as the factor.potential function.
        
        Parameter
        --------
        evidence: dict (optional)
            A dictionary containing variable:outcome pairs specifying
            the evidental state of the parent nodes.
            
        Returns
        -------
        dict
            A dictionary containing the outcomes of this variable as keys
            and their corresponding (conditional) probabilities given
            the evidence if present.
    &#34;&#34;&#34;
    #Construct the index for the desired potential
    index = [list(range(len(self.outcomes)))]
    for p in self.parent_order:
        if p in evidence:
            try:
                index.append([self.parents[p].outcomes.index(evidence[p])])
            except ValueError:
                raise ValueError(&#34;The parent {} does not have the outcome &#34; + \
                                 &#34;{}&#34;.format(p, evidence[p]))
        else:
            raise ValueError(&#34;In order to get a distribution for this &#34; + \
                             &#34;variable, all it&#39;s parents need to be specified &#34; + \
                             &#34;as evidence, but {} was not specified.&#34;.format(p))
                
    #np.ix_ constructs an access mask which allows efficient access
    #to the desired cells. This approach allows underspecification of the
    #instantiation (i.e. not all variables are specified) which will
    #result in returning a matrix for the remaining variables
    probs = np.squeeze(self.cpt[np.ix_(*index)])
    return {outcome: probs[i] for i,outcome in enumerate(self.outcomes)}</code></pre>
</details>
</dd>
<dt id="ccbase.nodes.DiscreteVariable.remove_parent"><code class="name flex">
<span>def <span class="ident">remove_parent</span></span>(<span>self, parent_node: <a title="ccbase.nodes.DiscreteVariable" href="#ccbase.nodes.DiscreteVariable">DiscreteVariable</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes the given parent node from this node's
parents. Uses the DiscreteVariable function while
making sure to update the parent_order as well.</p>
<h2 id="parameter">Parameter</h2>
<p>parent_node: DiscreteVariable
The DiscreteVariable to that is to be removed as a parent.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_parent(self, parent_node: DiscreteVariable):
    &#34;&#34;&#34;
        Removes the given parent node from this node&#39;s
        parents. Uses the DiscreteVariable function while
        making sure to update the parent_order as well.

        Parameter
        ---------
        parent_node: DiscreteVariable
            The DiscreteVariable to that is to be removed as a parent.
    &#34;&#34;&#34;
    if parent_node.name in self.parent_order:
        self.parent_order.remove(parent_node.name)
    super(DiscreteVariable,self).remove_parent(parent_node)</code></pre>
</details>
</dd>
<dt id="ccbase.nodes.DiscreteVariable.set_probability_table"><code class="name flex">
<span>def <span class="ident">set_probability_table</span></span>(<span>self, table: Iterable)</span>
</code></dt>
<dd>
<div class="desc"><p>Allows to set the conditional probability density(table) of this
node directly. Will check that the dimensions of the given cpd
is conform to the current dependency structure but will not perform
any tests on the actual values.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cpd</code></strong> :&ensp;<code>iterable</code></dt>
<dd>Table containing the conditional probabilities. Each variable
is represented by a dimension in the size of the number of its
outcomes.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_probability_table(self, table: Iterable):
    &#34;&#34;&#34;
        Allows to set the conditional probability density(table) of this
        node directly. Will check that the dimensions of the given cpd
        is conform to the current dependency structure but will not perform
        any tests on the actual values.
        
        Parameters
        ----------
        cpd : iterable
            Table containing the conditional probabilities. Each variable 
            is represented by a dimension in the size of the number of its
            outcomes.
    &#34;&#34;&#34;
    
    # Check what dimensions the cpt would need to have given the current
    # parent structure of this node
    dimensions = [len(self.outcomes)]
    for parent_name in self.parent_order:
        dimensions.append(len(self.parents[parent_name].outcomes))
    #Make sure table is a numpy array and create copy.
    npTable = np.array(table)
    if npTable.shape != tuple(dimensions):
        raise ValueError(&#34;The dimensions of the given cpd do not match &#34; + \
                         &#34;the dependency structure of the node.&#34;)
    # Set the table
    self.cpt = npTable</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ccbase.nodes.Node" href="#ccbase.nodes.Node">Node</a></b></code>:
<ul class="hlist">
<li><code><a title="ccbase.nodes.Node.add_child" href="#ccbase.nodes.Node.add_child">add_child</a></code></li>
<li><code><a title="ccbase.nodes.Node.destroy" href="#ccbase.nodes.Node.destroy">destroy</a></code></li>
<li><code><a title="ccbase.nodes.Node.remove_child" href="#ccbase.nodes.Node.remove_child">remove_child</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ccbase.nodes.Node"><code class="flex name class">
<span>class <span class="ident">Node</span></span>
<span>(</span><span>name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for nodes within a graph.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>String</code></dt>
<dd>The name or identifier of the node</dd>
<dt><strong><code>parents</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary containing parent-name:Node pairs for all parents of this node</dd>
<dt><strong><code>children</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary containing child-name:Node pairs for children of this node</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Node:
    &#34;&#34;&#34;
        Base class for nodes within a graph.

        Attributes
        ----------
        name: String
            The name or identifier of the node
        parents: dict
            A dictionary containing parent-name:Node pairs for all parents of this node
        children: dict
            A dictionary containing child-name:Node pairs for children of this node

    &#34;&#34;&#34;
    
    def __init__(self, name: str):
        self.name = name
        self.parents = {}
        self.children = {}
        
    def add_parent(self, parent: Node):
        &#34;&#34;&#34;
            Add or overwrites a parent node. Will not check if there already is
            a parent with the same name.
            
            Parameters
            ----------
            parent: Node
                The node to be added as parent.
        &#34;&#34;&#34;
        self.parents[parent.name] = parent
        
    def add_child(self, child: Node):
        &#34;&#34;&#34;
            Add or overwrites a child node. Will not check if there already is
            a child with the same name.
            
            Parameters
            ----------
            child: Node
                The node to be added as child.
        &#34;&#34;&#34;
        self.children[child.name] = child
        
    def remove_parent(self, parent: Node):
        &#34;&#34;&#34;
            Removes a parent node if it exists. If it did not exist, will do 
            nothing.
            
            Parameters
            ----------
            parent: Node
                The node to be removed as parent.
        &#34;&#34;&#34;
        
        if parent.name in self.parents:
            del self.parents[parent.name]
            
    def remove_child(self, child: Node):
        &#34;&#34;&#34;
            Removes a child node if it exists. If it did not exist, will do 
            nothing.
            
            Parameters
            ----------
            child: Node
                The node to be removed as child.
        &#34;&#34;&#34;
        if child.name in self.children:
            del self.children[child.name]
        
    def destroy(self):
        &#34;&#34;&#34;
            &#34;Destroys&#34; the node by removing its link to all its neighbours.
            This will **not** destroy the actual node object. This would have
            to be taken care of elsewhere.
        &#34;&#34;&#34;
        for p in self.parents.values():
            p.remove_child(self)
        
        for c in self.children.values():
            c.remove_parent(self)
        self.parents = {}
        self.children = {}
        
    def __hash__(self) -&gt; str:
        &#34;&#34;&#34;
            The hash of a node is the same as the hash of its name.
            This allows to reference nodes in dictionaries by their object
            instantiation or their name.
        &#34;&#34;&#34;
        return hash(self.name)
        
    def __str__(self) -&gt; str:
        &#34;&#34;&#34;
            Overwrites the default string representation of this class to just
            return it&#39;s name.
        &#34;&#34;&#34;
        return self.name
    
    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;
            Overwrites the default string representation of this class to just
            return it&#39;s name.
        &#34;&#34;&#34;
        return self.name
    
    def __eq__(self, other: Node) -&gt; bool:
        &#34;&#34;&#34;
            Two nodes are considered to be identical if they have the
            same name.
            In order for the access in dictionaries via the name to work, a
            random node is equal to its name as well.
        &#34;&#34;&#34;
        try:
            return other.name == self.name
        except AttributeError:
            return other == self.name
        
    def __ne__(self, other: Node) -&gt; bool:
        &#34;&#34;&#34;
            Checking if the given node is NOT equal to the current instance.
        &#34;&#34;&#34;
        return not self.__eq__(other)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="ccbase.nodes.DiscreteVariable" href="#ccbase.nodes.DiscreteVariable">DiscreteVariable</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ccbase.nodes.Node.add_child"><code class="name flex">
<span>def <span class="ident">add_child</span></span>(<span>self, child: <a title="ccbase.nodes.Node" href="#ccbase.nodes.Node">Node</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Add or overwrites a child node. Will not check if there already is
a child with the same name.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>child</code></strong> :&ensp;<code><a title="ccbase.nodes.Node" href="#ccbase.nodes.Node">Node</a></code></dt>
<dd>The node to be added as child.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_child(self, child: Node):
    &#34;&#34;&#34;
        Add or overwrites a child node. Will not check if there already is
        a child with the same name.
        
        Parameters
        ----------
        child: Node
            The node to be added as child.
    &#34;&#34;&#34;
    self.children[child.name] = child</code></pre>
</details>
</dd>
<dt id="ccbase.nodes.Node.add_parent"><code class="name flex">
<span>def <span class="ident">add_parent</span></span>(<span>self, parent: <a title="ccbase.nodes.Node" href="#ccbase.nodes.Node">Node</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Add or overwrites a parent node. Will not check if there already is
a parent with the same name.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>parent</code></strong> :&ensp;<code><a title="ccbase.nodes.Node" href="#ccbase.nodes.Node">Node</a></code></dt>
<dd>The node to be added as parent.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_parent(self, parent: Node):
    &#34;&#34;&#34;
        Add or overwrites a parent node. Will not check if there already is
        a parent with the same name.
        
        Parameters
        ----------
        parent: Node
            The node to be added as parent.
    &#34;&#34;&#34;
    self.parents[parent.name] = parent</code></pre>
</details>
</dd>
<dt id="ccbase.nodes.Node.destroy"><code class="name flex">
<span>def <span class="ident">destroy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>"Destroys" the node by removing its link to all its neighbours.
This will <strong>not</strong> destroy the actual node object. This would have
to be taken care of elsewhere.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def destroy(self):
    &#34;&#34;&#34;
        &#34;Destroys&#34; the node by removing its link to all its neighbours.
        This will **not** destroy the actual node object. This would have
        to be taken care of elsewhere.
    &#34;&#34;&#34;
    for p in self.parents.values():
        p.remove_child(self)
    
    for c in self.children.values():
        c.remove_parent(self)
    self.parents = {}
    self.children = {}</code></pre>
</details>
</dd>
<dt id="ccbase.nodes.Node.remove_child"><code class="name flex">
<span>def <span class="ident">remove_child</span></span>(<span>self, child: <a title="ccbase.nodes.Node" href="#ccbase.nodes.Node">Node</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes a child node if it exists. If it did not exist, will do
nothing.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>child</code></strong> :&ensp;<code><a title="ccbase.nodes.Node" href="#ccbase.nodes.Node">Node</a></code></dt>
<dd>The node to be removed as child.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_child(self, child: Node):
    &#34;&#34;&#34;
        Removes a child node if it exists. If it did not exist, will do 
        nothing.
        
        Parameters
        ----------
        child: Node
            The node to be removed as child.
    &#34;&#34;&#34;
    if child.name in self.children:
        del self.children[child.name]</code></pre>
</details>
</dd>
<dt id="ccbase.nodes.Node.remove_parent"><code class="name flex">
<span>def <span class="ident">remove_parent</span></span>(<span>self, parent: <a title="ccbase.nodes.Node" href="#ccbase.nodes.Node">Node</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes a parent node if it exists. If it did not exist, will do
nothing.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>parent</code></strong> :&ensp;<code><a title="ccbase.nodes.Node" href="#ccbase.nodes.Node">Node</a></code></dt>
<dd>The node to be removed as parent.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_parent(self, parent: Node):
    &#34;&#34;&#34;
        Removes a parent node if it exists. If it did not exist, will do 
        nothing.
        
        Parameters
        ----------
        parent: Node
            The node to be removed as parent.
    &#34;&#34;&#34;
    
    if parent.name in self.parents:
        del self.parents[parent.name]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ccbase" href="index.html">ccbase</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ccbase.nodes.DiscreteVariable" href="#ccbase.nodes.DiscreteVariable">DiscreteVariable</a></code></h4>
<ul class="">
<li><code><a title="ccbase.nodes.DiscreteVariable.add_parent" href="#ccbase.nodes.DiscreteVariable.add_parent">add_parent</a></code></li>
<li><code><a title="ccbase.nodes.DiscreteVariable.get_distribution" href="#ccbase.nodes.DiscreteVariable.get_distribution">get_distribution</a></code></li>
<li><code><a title="ccbase.nodes.DiscreteVariable.remove_parent" href="#ccbase.nodes.DiscreteVariable.remove_parent">remove_parent</a></code></li>
<li><code><a title="ccbase.nodes.DiscreteVariable.set_probability_table" href="#ccbase.nodes.DiscreteVariable.set_probability_table">set_probability_table</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ccbase.nodes.Node" href="#ccbase.nodes.Node">Node</a></code></h4>
<ul class="">
<li><code><a title="ccbase.nodes.Node.add_child" href="#ccbase.nodes.Node.add_child">add_child</a></code></li>
<li><code><a title="ccbase.nodes.Node.add_parent" href="#ccbase.nodes.Node.add_parent">add_parent</a></code></li>
<li><code><a title="ccbase.nodes.Node.destroy" href="#ccbase.nodes.Node.destroy">destroy</a></code></li>
<li><code><a title="ccbase.nodes.Node.remove_child" href="#ccbase.nodes.Node.remove_child">remove_child</a></code></li>
<li><code><a title="ccbase.nodes.Node.remove_parent" href="#ccbase.nodes.Node.remove_parent">remove_parent</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>