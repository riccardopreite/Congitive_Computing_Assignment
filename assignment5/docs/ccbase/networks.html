<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ccbase.networks API documentation</title>
<meta name="description" content="Created on Thu Apr 27 13:46:30 2017
Refactored module for holding graphical networks. At this point we only
need our graph class and its subclass for â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ccbase.networks</code></h1>
</header>
<section id="section-intro">
<p>Created on Thu Apr 27 13:46:30 2017
Refactored module for holding graphical networks. At this point we only
need our graph class and its subclass for Bayesian networks.
@author: jpoeppel</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-
&#34;&#34;&#34;
Created on Thu Apr 27 13:46:30 2017
Refactored module for holding graphical networks. At this point we only
need our graph class and its subclass for Bayesian networks.
@author: jpoeppel
&#34;&#34;&#34;
from __future__ import annotations

import copy
from typing import Union, Optional, List, Dict, Iterable

from .nodes import DiscreteVariable, Node
from .factor import Factor

import numpy as np

class Graph:
    
    def __init__(self):
        self.nodes = {}
        self.is_directed = True
        
    def add_node(self, node: Union[str, Node]):
        &#34;&#34;&#34;
            Adds a node to the graph. Will first create a new node object
            with the given name.
            
            Parameters
            ----------
            node: String or Node
                The name of the new node or the new node directly. In case
                a string is passed, a new node will be created before adding it.
        &#34;&#34;&#34;
        if node in self.nodes:
            raise ValueError(&#34;The graph already contains a node named {}&#34;.format(node))
        
        try:
            self.nodes[node.name] = node
        except AttributeError: #We check for an attribute, rather than a type.
            self.nodes[node] = Node(node)
        
    def remove_node(self, node: Union[str, Node]):
        &#34;&#34;&#34;
            Removes the node with the given name from the graph.
            
            Parameters
            ----------
            node: String or Node
                The name of the new node or the node object itself.
        &#34;&#34;&#34;
        if not node in self.nodes:
            raise ValueError(&#34;The graph does not contain a node named {}&#34;.format(node))
        
        self.nodes[node].destroy()
        del self.nodes[node]
        
    def add_edge(self, node1: Union[str, Node], node2: Union[str, Node]):
        &#34;&#34;&#34;
            Adds a directed edge from node1 to node2. In this implementation, edges
            are only implictly represented, via parent and child relations in the
            nodes. One could alternatively explicitly represent edge objects that
            connect nodes.
            
            Parameters
            ----------
            node1: String or Node
                The name of the first node. The node object can also be used.
            node2: String or Node
                The name of the second node. The node object can also be used.

            Raises
            ------
            ValueError
                When either of the two nodes does not exist in the graph.
        &#34;&#34;&#34;
        try:
            self.nodes[node1].add_child(self.nodes[node2])
            self.nodes[node2].add_parent(self.nodes[node1])
            self.is_directed = True
        except KeyError:
            raise ValueError(&#34;At least one of your specified nodes ({},{}) &#34; \
                             &#34;is not contained in the graph&#34;.format(node1, node2))
            
    def remove_edge(self, node1: Union[str, Node], node2: Union[str, Node]):
        &#34;&#34;&#34;
            Removes an edge from node1 to node2, if it exists. Ignores incorrect
            edges.
            
            Parameters
            ----------
            node1: String or Node
                The name of the first node. The node object can also be used.
            node2: String or Node
                The name of the second node. The node object can also be used.
            Raises
            ------
            ValueError
                When either of the two nodes does not exist in the graph.
        &#34;&#34;&#34;
        try:
            self.nodes[node1].remove_child(self.nodes[node2])
            self.nodes[node2].remove_parent(self.nodes[node1])
        except KeyError:
            raise ValueError(&#34;At least one of your specified nodes ({},{}) &#34; \
                             &#34;is not contained in the graph&#34;.format(node1, node2))
            
    def get_number_of_nodes(self):
        &#34;&#34;&#34;
            Returns
            -------
            int
                The total number of nodes in the graph.
        &#34;&#34;&#34;
        return len(self.nodes)
    
    def get_parents(self, node: Union[str, Node]):
        &#34;&#34;&#34;
            Parameters
            ----------
            node: String or Node
                The name of the node whose parents are queried.
                The Node object itself can also be used.
                
            Returns
            -------
            list
                A list containing all parent nodes of the specified node.

            Raises
            ------
            ValueError
                When the graph does not contain the queried node.
        &#34;&#34;&#34;
        try:
            return self.nodes[node].parents.values()
        except KeyError:
            raise ValueError(&#34;The graph does not contain a node called {}&#34;.format(node))
            
    def get_children(self, node: Union[str, Node]):
        &#34;&#34;&#34;
            Parameters
            ----------
            node: String
                The name of the node whose children are queried.
                The Node object itself can also be used.
                
            Returns
            -------
            list
                A list containing all children nodes of the specified node.

            Raises
            ------
            ValueError
                When the graph does not contain the queried node.
        &#34;&#34;&#34;
        try:
            return self.nodes[node].children.values()
        except KeyError:
            raise ValueError(&#34;The graph does not contain a node called {}&#34;.format(node)) 
            
    def get_ancestors(self, node: Union[str, Node]):
        &#34;&#34;&#34;
            Parameters
            ----------
            node: String or Node
                The name of the node whose ancestors are queried.
                The Node object itself can also be used.
                
            Returns
            -------
            list
                A list containing all ancestor nodes of the specified node.

            Raises
            ------
            ValueError
                When the graph does not contain the queried node.
        &#34;&#34;&#34;
        if not node in self.nodes:
            raise ValueError(&#34;The graph does not contain a node called {}&#34;.format(node))
        def _add_parents(tmpNode):
            for p in tmpNode.parents.values():
                if p in res:
                    continue
                res.add(p)
                _add_parents(p)
        res = set()
        _add_parents(self.nodes[node])
        return res

    def is_ancestor(self, node_a: Union[str, Node], node_b: Union[str, Node]) -&gt; bool:
        &#34;&#34;&#34;
            Checks if node_a is an ancestor of node_b. 
            Should also work in cyclic graphs!

            Parameters
            ----------
            node_a: String
                The name of the potential ancestor node.
            node_b: String
                The name of the potential descendant node.

            Returns
            -------
            bool
                True if node_a is an ancestor of node_b, False otherwise.
        &#34;&#34;&#34;
        return node_a in self.get_ancestors(node_b)

    def is_descendant(self, node_a: Union[str, Node], node_b: Union[str, Node]) -&gt; bool:
        &#34;&#34;&#34;
            Checks if node_a is a descendant of node_b. 
            Should also work in cyclic graphs!

            Parameters
            ----------
            node_a: String
                The name of the potential descendant node.
            node_b: String
                The name of the potential ancestor node.

            Returns
            -------
            bool
                True if node_a is a descendant of node_b, False otherwise.
        &#34;&#34;&#34;
        return node_b in self.get_ancestors(node_a)

    def is_acyclic(self) -&gt; bool:
        &#34;&#34;&#34;
            Computes whether or not this graph is acyclic.
        
            Returns
            ----------
            bool
                True if there are no cycles within the provided graph, False otherwise.
        &#34;&#34;&#34;
        def _cyclic(node):
            &#34;&#34;&#34;
                Private helper function to check if a node is cyclic.
                
                This basically implements a marking/painting algorithm going over all
                nodes and marking them according to 0=not yet visited, 1=currently
                active and 2=done, but with the short circuit of breaking as soon
                as we find a loop (i.e. we meet another node, that is currently
                active).
            &#34;&#34;&#34;
            if statusMap[node] == 2:
                return False
            if statusMap[node] == 1:
                return True
            statusMap[node] = 1
            for n in node.children.values():
                if _cyclic(n):
                    return True
            statusMap[node] = 2
            return False
        
        statusMap = {}
        for n in self.nodes.values():
            statusMap[n] = 0
        for n in self.nodes.values():
            if _cyclic(n):
                return False

        return True
            
    def copy(self, deep: Optional[bool] = True) -&gt; Graph:
        &#34;&#34;&#34;
            Copies the current graph.
            
            Parameters
            ----------
            deep: Bool
                If true, a deep copy will be performed, i.e. all nodes are also
                copied. In a shallow copy, both graph instances will contain the
                same node references.
            
            Returns
            -------
            Graph
                Creates a (deep) copy of this graph.
        &#34;&#34;&#34;
       
        if deep:
            return copy.deepcopy(self)
        else:
             return copy.copy(self)
            
    def to_undirected(self) -&gt; Graph:
        &#34;&#34;&#34;
            Returns an undirected copy this graph. Sine this implementation
            does not really specify edge directions, we consider a bidrectional
            graph as undirected!
            
            Returns
            -------
            Graph
                An undirected copy of this graph.
        &#34;&#34;&#34;
        res = self.copy()
        if res.is_directed:
            for n in res.nodes.values():
                for p in n.parents.values():
                    n.add_child(p)
                    p.add_parent(n)
                for c in n.children.values():
                    c.add_child(n)
                    n.add_parent(c)
            res.is_directed = False  
        return res
        

class BayesianNetwork(Graph):
    &#34;&#34;&#34;
        Currently our Bayesian Network will simply be the same as our graph,
        but so that we can extend it later if needed, we subclass it here.
    &#34;&#34;&#34;
    def __init__(self):
        #Call the constructor of the Graph class.
        super(BayesianNetwork, self).__init__()
        
    def marginals(self, node: Union[str, DiscreteVariable], evidence: Optional[Dict[str,str]]=None) -&gt; np.array:
        &#34;&#34;&#34;
            Computes the exact marginals for the node, given the evidence in 
            this network, using the old factor class.
            
            Note: The factor class will work correctly as long as the cpts of
            the nodes which created the factors were correct.
            
            Parameters
            ----------
            node : DiscreteVariable, String
                Either the node or the name of the node for which the marginals
                should be computed
                
            evidence : dict (optional)
                A dictionary containing node : outcome pairs to specify the 
                state of the given variables.
                
            Returns
            -------
            np.array
                A 1D array containing the marginals for the given node
        &#34;&#34;&#34;
        # Make sure node is actually a DiscreteVariable
        node = self.nodes[node]
        node_name = self.nodes[node].name
        factors = [Factor.from_node(n) for n in self.nodes.values()]

        if evidence:
            #reduce factors by their evidence
            factors = [f.reduce(evidence) for f in factors]

        # Eliminate all non-query variables
        for v in self.get_elimination_ordering():
            if v == node_name:
                continue
            
            new_factor = Factor()
            new_factors = []
            for f in factors:
                if v in f.variable_order:
                    new_factor = new_factor * f
                else:
                    new_factors.append(f)
            new_factor = new_factor.marginalize(v)
            
            new_factors.append(new_factor)
            factors = new_factors
            
        fres = Factor()
        for f in factors:
            fres = fres * f
        
        return fres.potentials/np.sum(fres.potentials)
    
    def get_probability(self, instantiation: Dict[str, str], 
                            evidence: Optional[Dict[str, str]]=None) -&gt; float:
        &#34;&#34;&#34;
            Computes the exact (posterior) probabiliy for the given
            instantiation, 
            e.g. net.get_probability({&#34;A&#34;:&#34;a&#34;, &#34;B&#34;:&#34;b&#34;) = P(A=a, B=b)
            
            Parameters
            ----------
            instantiation: dict
                A dictionary containing variable:outcome pairs specifying the
                probability one is interested in.
                
            evidence : dict (optional)
                A dictionary containing node : outcome pairs to specify the 
                state of the given variables.
                
            Returns
            -------
            float
                The probability for the given instantiation.
                
        &#34;&#34;&#34;
        factors = [Factor.from_node(n) for n in self.nodes.values()]

        if evidence:
            #reduce factors by their evidence
            factors = [f.reduce(evidence) for f in factors]

        # Eliminate all non-query variables
        for v in self.get_elimination_ordering():
            if v in instantiation.keys():
                continue
            
            new_factor = Factor()
            new_factors = []
            for f in factors:
                if v in f.variable_order:
                    new_factor = new_factor * f
                else:
                    new_factors.append(f)
            new_factor = new_factor.marginalize(v)
            
            new_factors.append(new_factor)
            factors = new_factors
            
        fres = Factor()
        for f in factors:
            fres = fres * f
        fres.potentials /= np.sum(fres.potentials)
        return fres.potential(instantiation)
                    
                
                    
    def get_elimination_ordering(self) -&gt; List[str]:
       &#34;&#34;&#34;
           Dummy elimination order implementation.
       &#34;&#34;&#34;
       return list(self.nodes.keys())
    
    def to_undirected(self):
        raise NotImplementedError(&#34;A Bayesian Network cannot be undirected!&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ccbase.networks.BayesianNetwork"><code class="flex name class">
<span>class <span class="ident">BayesianNetwork</span></span>
</code></dt>
<dd>
<div class="desc"><p>Currently our Bayesian Network will simply be the same as our graph,
but so that we can extend it later if needed, we subclass it here.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BayesianNetwork(Graph):
    &#34;&#34;&#34;
        Currently our Bayesian Network will simply be the same as our graph,
        but so that we can extend it later if needed, we subclass it here.
    &#34;&#34;&#34;
    def __init__(self):
        #Call the constructor of the Graph class.
        super(BayesianNetwork, self).__init__()
        
    def marginals(self, node: Union[str, DiscreteVariable], evidence: Optional[Dict[str,str]]=None) -&gt; np.array:
        &#34;&#34;&#34;
            Computes the exact marginals for the node, given the evidence in 
            this network, using the old factor class.
            
            Note: The factor class will work correctly as long as the cpts of
            the nodes which created the factors were correct.
            
            Parameters
            ----------
            node : DiscreteVariable, String
                Either the node or the name of the node for which the marginals
                should be computed
                
            evidence : dict (optional)
                A dictionary containing node : outcome pairs to specify the 
                state of the given variables.
                
            Returns
            -------
            np.array
                A 1D array containing the marginals for the given node
        &#34;&#34;&#34;
        # Make sure node is actually a DiscreteVariable
        node = self.nodes[node]
        node_name = self.nodes[node].name
        factors = [Factor.from_node(n) for n in self.nodes.values()]

        if evidence:
            #reduce factors by their evidence
            factors = [f.reduce(evidence) for f in factors]

        # Eliminate all non-query variables
        for v in self.get_elimination_ordering():
            if v == node_name:
                continue
            
            new_factor = Factor()
            new_factors = []
            for f in factors:
                if v in f.variable_order:
                    new_factor = new_factor * f
                else:
                    new_factors.append(f)
            new_factor = new_factor.marginalize(v)
            
            new_factors.append(new_factor)
            factors = new_factors
            
        fres = Factor()
        for f in factors:
            fres = fres * f
        
        return fres.potentials/np.sum(fres.potentials)
    
    def get_probability(self, instantiation: Dict[str, str], 
                            evidence: Optional[Dict[str, str]]=None) -&gt; float:
        &#34;&#34;&#34;
            Computes the exact (posterior) probabiliy for the given
            instantiation, 
            e.g. net.get_probability({&#34;A&#34;:&#34;a&#34;, &#34;B&#34;:&#34;b&#34;) = P(A=a, B=b)
            
            Parameters
            ----------
            instantiation: dict
                A dictionary containing variable:outcome pairs specifying the
                probability one is interested in.
                
            evidence : dict (optional)
                A dictionary containing node : outcome pairs to specify the 
                state of the given variables.
                
            Returns
            -------
            float
                The probability for the given instantiation.
                
        &#34;&#34;&#34;
        factors = [Factor.from_node(n) for n in self.nodes.values()]

        if evidence:
            #reduce factors by their evidence
            factors = [f.reduce(evidence) for f in factors]

        # Eliminate all non-query variables
        for v in self.get_elimination_ordering():
            if v in instantiation.keys():
                continue
            
            new_factor = Factor()
            new_factors = []
            for f in factors:
                if v in f.variable_order:
                    new_factor = new_factor * f
                else:
                    new_factors.append(f)
            new_factor = new_factor.marginalize(v)
            
            new_factors.append(new_factor)
            factors = new_factors
            
        fres = Factor()
        for f in factors:
            fres = fres * f
        fres.potentials /= np.sum(fres.potentials)
        return fres.potential(instantiation)
                    
                
                    
    def get_elimination_ordering(self) -&gt; List[str]:
       &#34;&#34;&#34;
           Dummy elimination order implementation.
       &#34;&#34;&#34;
       return list(self.nodes.keys())
    
    def to_undirected(self):
        raise NotImplementedError(&#34;A Bayesian Network cannot be undirected!&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ccbase.networks.Graph" href="#ccbase.networks.Graph">Graph</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ccbase.networks.BayesianNetwork.get_elimination_ordering"><code class="name flex">
<span>def <span class="ident">get_elimination_ordering</span></span>(<span>self) â€‘>Â List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Dummy elimination order implementation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_elimination_ordering(self) -&gt; List[str]:
   &#34;&#34;&#34;
       Dummy elimination order implementation.
   &#34;&#34;&#34;
   return list(self.nodes.keys())</code></pre>
</details>
</dd>
<dt id="ccbase.networks.BayesianNetwork.get_probability"><code class="name flex">
<span>def <span class="ident">get_probability</span></span>(<span>self, instantiation:Â Dict[str,Â str], evidence:Â Optional[Dict[str,Â str]]Â =Â None) â€‘>Â float</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the exact (posterior) probabiliy for the given
instantiation,
e.g. net.get_probability({"A":"a", "B":"b") = P(A=a, B=b)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>instantiation</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary containing variable:outcome pairs specifying the
probability one is interested in.</dd>
<dt><strong><code>evidence</code></strong> :&ensp;<code>dict (optional)</code></dt>
<dd>A dictionary containing node : outcome pairs to specify the
state of the given variables.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>The probability for the given instantiation.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_probability(self, instantiation: Dict[str, str], 
                        evidence: Optional[Dict[str, str]]=None) -&gt; float:
    &#34;&#34;&#34;
        Computes the exact (posterior) probabiliy for the given
        instantiation, 
        e.g. net.get_probability({&#34;A&#34;:&#34;a&#34;, &#34;B&#34;:&#34;b&#34;) = P(A=a, B=b)
        
        Parameters
        ----------
        instantiation: dict
            A dictionary containing variable:outcome pairs specifying the
            probability one is interested in.
            
        evidence : dict (optional)
            A dictionary containing node : outcome pairs to specify the 
            state of the given variables.
            
        Returns
        -------
        float
            The probability for the given instantiation.
            
    &#34;&#34;&#34;
    factors = [Factor.from_node(n) for n in self.nodes.values()]

    if evidence:
        #reduce factors by their evidence
        factors = [f.reduce(evidence) for f in factors]

    # Eliminate all non-query variables
    for v in self.get_elimination_ordering():
        if v in instantiation.keys():
            continue
        
        new_factor = Factor()
        new_factors = []
        for f in factors:
            if v in f.variable_order:
                new_factor = new_factor * f
            else:
                new_factors.append(f)
        new_factor = new_factor.marginalize(v)
        
        new_factors.append(new_factor)
        factors = new_factors
        
    fres = Factor()
    for f in factors:
        fres = fres * f
    fres.potentials /= np.sum(fres.potentials)
    return fres.potential(instantiation)</code></pre>
</details>
</dd>
<dt id="ccbase.networks.BayesianNetwork.marginals"><code class="name flex">
<span>def <span class="ident">marginals</span></span>(<span>self, node:Â Union[str,Â DiscreteVariable], evidence:Â Optional[Dict[str,Â str]]Â =Â None) â€‘>Â <built-inÂ functionÂ array></span>
</code></dt>
<dd>
<div class="desc"><p>Computes the exact marginals for the node, given the evidence in
this network, using the old factor class.</p>
<p>Note: The factor class will work correctly as long as the cpts of
the nodes which created the factors were correct.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>DiscreteVariable, String</code></dt>
<dd>Either the node or the name of the node for which the marginals
should be computed</dd>
<dt><strong><code>evidence</code></strong> :&ensp;<code>dict (optional)</code></dt>
<dd>A dictionary containing node : outcome pairs to specify the
state of the given variables.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.array</code></dt>
<dd>A 1D array containing the marginals for the given node</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def marginals(self, node: Union[str, DiscreteVariable], evidence: Optional[Dict[str,str]]=None) -&gt; np.array:
    &#34;&#34;&#34;
        Computes the exact marginals for the node, given the evidence in 
        this network, using the old factor class.
        
        Note: The factor class will work correctly as long as the cpts of
        the nodes which created the factors were correct.
        
        Parameters
        ----------
        node : DiscreteVariable, String
            Either the node or the name of the node for which the marginals
            should be computed
            
        evidence : dict (optional)
            A dictionary containing node : outcome pairs to specify the 
            state of the given variables.
            
        Returns
        -------
        np.array
            A 1D array containing the marginals for the given node
    &#34;&#34;&#34;
    # Make sure node is actually a DiscreteVariable
    node = self.nodes[node]
    node_name = self.nodes[node].name
    factors = [Factor.from_node(n) for n in self.nodes.values()]

    if evidence:
        #reduce factors by their evidence
        factors = [f.reduce(evidence) for f in factors]

    # Eliminate all non-query variables
    for v in self.get_elimination_ordering():
        if v == node_name:
            continue
        
        new_factor = Factor()
        new_factors = []
        for f in factors:
            if v in f.variable_order:
                new_factor = new_factor * f
            else:
                new_factors.append(f)
        new_factor = new_factor.marginalize(v)
        
        new_factors.append(new_factor)
        factors = new_factors
        
    fres = Factor()
    for f in factors:
        fres = fres * f
    
    return fres.potentials/np.sum(fres.potentials)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ccbase.networks.Graph" href="#ccbase.networks.Graph">Graph</a></b></code>:
<ul class="hlist">
<li><code><a title="ccbase.networks.Graph.add_edge" href="#ccbase.networks.Graph.add_edge">add_edge</a></code></li>
<li><code><a title="ccbase.networks.Graph.add_node" href="#ccbase.networks.Graph.add_node">add_node</a></code></li>
<li><code><a title="ccbase.networks.Graph.copy" href="#ccbase.networks.Graph.copy">copy</a></code></li>
<li><code><a title="ccbase.networks.Graph.get_ancestors" href="#ccbase.networks.Graph.get_ancestors">get_ancestors</a></code></li>
<li><code><a title="ccbase.networks.Graph.get_children" href="#ccbase.networks.Graph.get_children">get_children</a></code></li>
<li><code><a title="ccbase.networks.Graph.get_number_of_nodes" href="#ccbase.networks.Graph.get_number_of_nodes">get_number_of_nodes</a></code></li>
<li><code><a title="ccbase.networks.Graph.get_parents" href="#ccbase.networks.Graph.get_parents">get_parents</a></code></li>
<li><code><a title="ccbase.networks.Graph.is_acyclic" href="#ccbase.networks.Graph.is_acyclic">is_acyclic</a></code></li>
<li><code><a title="ccbase.networks.Graph.is_ancestor" href="#ccbase.networks.Graph.is_ancestor">is_ancestor</a></code></li>
<li><code><a title="ccbase.networks.Graph.is_descendant" href="#ccbase.networks.Graph.is_descendant">is_descendant</a></code></li>
<li><code><a title="ccbase.networks.Graph.remove_edge" href="#ccbase.networks.Graph.remove_edge">remove_edge</a></code></li>
<li><code><a title="ccbase.networks.Graph.remove_node" href="#ccbase.networks.Graph.remove_node">remove_node</a></code></li>
<li><code><a title="ccbase.networks.Graph.to_undirected" href="#ccbase.networks.Graph.to_undirected">to_undirected</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ccbase.networks.Graph"><code class="flex name class">
<span>class <span class="ident">Graph</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Graph:
    
    def __init__(self):
        self.nodes = {}
        self.is_directed = True
        
    def add_node(self, node: Union[str, Node]):
        &#34;&#34;&#34;
            Adds a node to the graph. Will first create a new node object
            with the given name.
            
            Parameters
            ----------
            node: String or Node
                The name of the new node or the new node directly. In case
                a string is passed, a new node will be created before adding it.
        &#34;&#34;&#34;
        if node in self.nodes:
            raise ValueError(&#34;The graph already contains a node named {}&#34;.format(node))
        
        try:
            self.nodes[node.name] = node
        except AttributeError: #We check for an attribute, rather than a type.
            self.nodes[node] = Node(node)
        
    def remove_node(self, node: Union[str, Node]):
        &#34;&#34;&#34;
            Removes the node with the given name from the graph.
            
            Parameters
            ----------
            node: String or Node
                The name of the new node or the node object itself.
        &#34;&#34;&#34;
        if not node in self.nodes:
            raise ValueError(&#34;The graph does not contain a node named {}&#34;.format(node))
        
        self.nodes[node].destroy()
        del self.nodes[node]
        
    def add_edge(self, node1: Union[str, Node], node2: Union[str, Node]):
        &#34;&#34;&#34;
            Adds a directed edge from node1 to node2. In this implementation, edges
            are only implictly represented, via parent and child relations in the
            nodes. One could alternatively explicitly represent edge objects that
            connect nodes.
            
            Parameters
            ----------
            node1: String or Node
                The name of the first node. The node object can also be used.
            node2: String or Node
                The name of the second node. The node object can also be used.

            Raises
            ------
            ValueError
                When either of the two nodes does not exist in the graph.
        &#34;&#34;&#34;
        try:
            self.nodes[node1].add_child(self.nodes[node2])
            self.nodes[node2].add_parent(self.nodes[node1])
            self.is_directed = True
        except KeyError:
            raise ValueError(&#34;At least one of your specified nodes ({},{}) &#34; \
                             &#34;is not contained in the graph&#34;.format(node1, node2))
            
    def remove_edge(self, node1: Union[str, Node], node2: Union[str, Node]):
        &#34;&#34;&#34;
            Removes an edge from node1 to node2, if it exists. Ignores incorrect
            edges.
            
            Parameters
            ----------
            node1: String or Node
                The name of the first node. The node object can also be used.
            node2: String or Node
                The name of the second node. The node object can also be used.
            Raises
            ------
            ValueError
                When either of the two nodes does not exist in the graph.
        &#34;&#34;&#34;
        try:
            self.nodes[node1].remove_child(self.nodes[node2])
            self.nodes[node2].remove_parent(self.nodes[node1])
        except KeyError:
            raise ValueError(&#34;At least one of your specified nodes ({},{}) &#34; \
                             &#34;is not contained in the graph&#34;.format(node1, node2))
            
    def get_number_of_nodes(self):
        &#34;&#34;&#34;
            Returns
            -------
            int
                The total number of nodes in the graph.
        &#34;&#34;&#34;
        return len(self.nodes)
    
    def get_parents(self, node: Union[str, Node]):
        &#34;&#34;&#34;
            Parameters
            ----------
            node: String or Node
                The name of the node whose parents are queried.
                The Node object itself can also be used.
                
            Returns
            -------
            list
                A list containing all parent nodes of the specified node.

            Raises
            ------
            ValueError
                When the graph does not contain the queried node.
        &#34;&#34;&#34;
        try:
            return self.nodes[node].parents.values()
        except KeyError:
            raise ValueError(&#34;The graph does not contain a node called {}&#34;.format(node))
            
    def get_children(self, node: Union[str, Node]):
        &#34;&#34;&#34;
            Parameters
            ----------
            node: String
                The name of the node whose children are queried.
                The Node object itself can also be used.
                
            Returns
            -------
            list
                A list containing all children nodes of the specified node.

            Raises
            ------
            ValueError
                When the graph does not contain the queried node.
        &#34;&#34;&#34;
        try:
            return self.nodes[node].children.values()
        except KeyError:
            raise ValueError(&#34;The graph does not contain a node called {}&#34;.format(node)) 
            
    def get_ancestors(self, node: Union[str, Node]):
        &#34;&#34;&#34;
            Parameters
            ----------
            node: String or Node
                The name of the node whose ancestors are queried.
                The Node object itself can also be used.
                
            Returns
            -------
            list
                A list containing all ancestor nodes of the specified node.

            Raises
            ------
            ValueError
                When the graph does not contain the queried node.
        &#34;&#34;&#34;
        if not node in self.nodes:
            raise ValueError(&#34;The graph does not contain a node called {}&#34;.format(node))
        def _add_parents(tmpNode):
            for p in tmpNode.parents.values():
                if p in res:
                    continue
                res.add(p)
                _add_parents(p)
        res = set()
        _add_parents(self.nodes[node])
        return res

    def is_ancestor(self, node_a: Union[str, Node], node_b: Union[str, Node]) -&gt; bool:
        &#34;&#34;&#34;
            Checks if node_a is an ancestor of node_b. 
            Should also work in cyclic graphs!

            Parameters
            ----------
            node_a: String
                The name of the potential ancestor node.
            node_b: String
                The name of the potential descendant node.

            Returns
            -------
            bool
                True if node_a is an ancestor of node_b, False otherwise.
        &#34;&#34;&#34;
        return node_a in self.get_ancestors(node_b)

    def is_descendant(self, node_a: Union[str, Node], node_b: Union[str, Node]) -&gt; bool:
        &#34;&#34;&#34;
            Checks if node_a is a descendant of node_b. 
            Should also work in cyclic graphs!

            Parameters
            ----------
            node_a: String
                The name of the potential descendant node.
            node_b: String
                The name of the potential ancestor node.

            Returns
            -------
            bool
                True if node_a is a descendant of node_b, False otherwise.
        &#34;&#34;&#34;
        return node_b in self.get_ancestors(node_a)

    def is_acyclic(self) -&gt; bool:
        &#34;&#34;&#34;
            Computes whether or not this graph is acyclic.
        
            Returns
            ----------
            bool
                True if there are no cycles within the provided graph, False otherwise.
        &#34;&#34;&#34;
        def _cyclic(node):
            &#34;&#34;&#34;
                Private helper function to check if a node is cyclic.
                
                This basically implements a marking/painting algorithm going over all
                nodes and marking them according to 0=not yet visited, 1=currently
                active and 2=done, but with the short circuit of breaking as soon
                as we find a loop (i.e. we meet another node, that is currently
                active).
            &#34;&#34;&#34;
            if statusMap[node] == 2:
                return False
            if statusMap[node] == 1:
                return True
            statusMap[node] = 1
            for n in node.children.values():
                if _cyclic(n):
                    return True
            statusMap[node] = 2
            return False
        
        statusMap = {}
        for n in self.nodes.values():
            statusMap[n] = 0
        for n in self.nodes.values():
            if _cyclic(n):
                return False

        return True
            
    def copy(self, deep: Optional[bool] = True) -&gt; Graph:
        &#34;&#34;&#34;
            Copies the current graph.
            
            Parameters
            ----------
            deep: Bool
                If true, a deep copy will be performed, i.e. all nodes are also
                copied. In a shallow copy, both graph instances will contain the
                same node references.
            
            Returns
            -------
            Graph
                Creates a (deep) copy of this graph.
        &#34;&#34;&#34;
       
        if deep:
            return copy.deepcopy(self)
        else:
             return copy.copy(self)
            
    def to_undirected(self) -&gt; Graph:
        &#34;&#34;&#34;
            Returns an undirected copy this graph. Sine this implementation
            does not really specify edge directions, we consider a bidrectional
            graph as undirected!
            
            Returns
            -------
            Graph
                An undirected copy of this graph.
        &#34;&#34;&#34;
        res = self.copy()
        if res.is_directed:
            for n in res.nodes.values():
                for p in n.parents.values():
                    n.add_child(p)
                    p.add_parent(n)
                for c in n.children.values():
                    c.add_child(n)
                    n.add_parent(c)
            res.is_directed = False  
        return res</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="ccbase.networks.BayesianNetwork" href="#ccbase.networks.BayesianNetwork">BayesianNetwork</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ccbase.networks.Graph.add_edge"><code class="name flex">
<span>def <span class="ident">add_edge</span></span>(<span>self, node1:Â Union[str,Â Node], node2:Â Union[str,Â Node])</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a directed edge from node1 to node2. In this implementation, edges
are only implictly represented, via parent and child relations in the
nodes. One could alternatively explicitly represent edge objects that
connect nodes.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node1</code></strong> :&ensp;<code>String</code> or <code>Node</code></dt>
<dd>The name of the first node. The node object can also be used.</dd>
<dt><strong><code>node2</code></strong> :&ensp;<code>String</code> or <code>Node</code></dt>
<dd>The name of the second node. The node object can also be used.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>When either of the two nodes does not exist in the graph.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_edge(self, node1: Union[str, Node], node2: Union[str, Node]):
    &#34;&#34;&#34;
        Adds a directed edge from node1 to node2. In this implementation, edges
        are only implictly represented, via parent and child relations in the
        nodes. One could alternatively explicitly represent edge objects that
        connect nodes.
        
        Parameters
        ----------
        node1: String or Node
            The name of the first node. The node object can also be used.
        node2: String or Node
            The name of the second node. The node object can also be used.

        Raises
        ------
        ValueError
            When either of the two nodes does not exist in the graph.
    &#34;&#34;&#34;
    try:
        self.nodes[node1].add_child(self.nodes[node2])
        self.nodes[node2].add_parent(self.nodes[node1])
        self.is_directed = True
    except KeyError:
        raise ValueError(&#34;At least one of your specified nodes ({},{}) &#34; \
                         &#34;is not contained in the graph&#34;.format(node1, node2))</code></pre>
</details>
</dd>
<dt id="ccbase.networks.Graph.add_node"><code class="name flex">
<span>def <span class="ident">add_node</span></span>(<span>self, node:Â Union[str,Â Node])</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a node to the graph. Will first create a new node object
with the given name.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>String</code> or <code>Node</code></dt>
<dd>The name of the new node or the new node directly. In case
a string is passed, a new node will be created before adding it.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_node(self, node: Union[str, Node]):
    &#34;&#34;&#34;
        Adds a node to the graph. Will first create a new node object
        with the given name.
        
        Parameters
        ----------
        node: String or Node
            The name of the new node or the new node directly. In case
            a string is passed, a new node will be created before adding it.
    &#34;&#34;&#34;
    if node in self.nodes:
        raise ValueError(&#34;The graph already contains a node named {}&#34;.format(node))
    
    try:
        self.nodes[node.name] = node
    except AttributeError: #We check for an attribute, rather than a type.
        self.nodes[node] = Node(node)</code></pre>
</details>
</dd>
<dt id="ccbase.networks.Graph.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, deep:Â Optional[bool]Â =Â True) â€‘>Â <a title="ccbase.networks.Graph" href="#ccbase.networks.Graph">Graph</a></span>
</code></dt>
<dd>
<div class="desc"><p>Copies the current graph.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>deep</code></strong> :&ensp;<code>Bool</code></dt>
<dd>If true, a deep copy will be performed, i.e. all nodes are also
copied. In a shallow copy, both graph instances will contain the
same node references.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="ccbase.networks.Graph" href="#ccbase.networks.Graph">Graph</a></code></dt>
<dd>Creates a (deep) copy of this graph.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self, deep: Optional[bool] = True) -&gt; Graph:
    &#34;&#34;&#34;
        Copies the current graph.
        
        Parameters
        ----------
        deep: Bool
            If true, a deep copy will be performed, i.e. all nodes are also
            copied. In a shallow copy, both graph instances will contain the
            same node references.
        
        Returns
        -------
        Graph
            Creates a (deep) copy of this graph.
    &#34;&#34;&#34;
   
    if deep:
        return copy.deepcopy(self)
    else:
         return copy.copy(self)</code></pre>
</details>
</dd>
<dt id="ccbase.networks.Graph.get_ancestors"><code class="name flex">
<span>def <span class="ident">get_ancestors</span></span>(<span>self, node:Â Union[str,Â Node])</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>String</code> or <code>Node</code></dt>
<dd>The name of the node whose ancestors are queried.
The Node object itself can also be used.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>A list containing all ancestor nodes of the specified node.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>When the graph does not contain the queried node.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ancestors(self, node: Union[str, Node]):
    &#34;&#34;&#34;
        Parameters
        ----------
        node: String or Node
            The name of the node whose ancestors are queried.
            The Node object itself can also be used.
            
        Returns
        -------
        list
            A list containing all ancestor nodes of the specified node.

        Raises
        ------
        ValueError
            When the graph does not contain the queried node.
    &#34;&#34;&#34;
    if not node in self.nodes:
        raise ValueError(&#34;The graph does not contain a node called {}&#34;.format(node))
    def _add_parents(tmpNode):
        for p in tmpNode.parents.values():
            if p in res:
                continue
            res.add(p)
            _add_parents(p)
    res = set()
    _add_parents(self.nodes[node])
    return res</code></pre>
</details>
</dd>
<dt id="ccbase.networks.Graph.get_children"><code class="name flex">
<span>def <span class="ident">get_children</span></span>(<span>self, node:Â Union[str,Â Node])</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>String</code></dt>
<dd>The name of the node whose children are queried.
The Node object itself can also be used.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>A list containing all children nodes of the specified node.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>When the graph does not contain the queried node.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_children(self, node: Union[str, Node]):
    &#34;&#34;&#34;
        Parameters
        ----------
        node: String
            The name of the node whose children are queried.
            The Node object itself can also be used.
            
        Returns
        -------
        list
            A list containing all children nodes of the specified node.

        Raises
        ------
        ValueError
            When the graph does not contain the queried node.
    &#34;&#34;&#34;
    try:
        return self.nodes[node].children.values()
    except KeyError:
        raise ValueError(&#34;The graph does not contain a node called {}&#34;.format(node)) </code></pre>
</details>
</dd>
<dt id="ccbase.networks.Graph.get_number_of_nodes"><code class="name flex">
<span>def <span class="ident">get_number_of_nodes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The total number of nodes in the graph.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_number_of_nodes(self):
    &#34;&#34;&#34;
        Returns
        -------
        int
            The total number of nodes in the graph.
    &#34;&#34;&#34;
    return len(self.nodes)</code></pre>
</details>
</dd>
<dt id="ccbase.networks.Graph.get_parents"><code class="name flex">
<span>def <span class="ident">get_parents</span></span>(<span>self, node:Â Union[str,Â Node])</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>String</code> or <code>Node</code></dt>
<dd>The name of the node whose parents are queried.
The Node object itself can also be used.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>A list containing all parent nodes of the specified node.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>When the graph does not contain the queried node.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_parents(self, node: Union[str, Node]):
    &#34;&#34;&#34;
        Parameters
        ----------
        node: String or Node
            The name of the node whose parents are queried.
            The Node object itself can also be used.
            
        Returns
        -------
        list
            A list containing all parent nodes of the specified node.

        Raises
        ------
        ValueError
            When the graph does not contain the queried node.
    &#34;&#34;&#34;
    try:
        return self.nodes[node].parents.values()
    except KeyError:
        raise ValueError(&#34;The graph does not contain a node called {}&#34;.format(node))</code></pre>
</details>
</dd>
<dt id="ccbase.networks.Graph.is_acyclic"><code class="name flex">
<span>def <span class="ident">is_acyclic</span></span>(<span>self) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Computes whether or not this graph is acyclic.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if there are no cycles within the provided graph, False otherwise.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_acyclic(self) -&gt; bool:
    &#34;&#34;&#34;
        Computes whether or not this graph is acyclic.
    
        Returns
        ----------
        bool
            True if there are no cycles within the provided graph, False otherwise.
    &#34;&#34;&#34;
    def _cyclic(node):
        &#34;&#34;&#34;
            Private helper function to check if a node is cyclic.
            
            This basically implements a marking/painting algorithm going over all
            nodes and marking them according to 0=not yet visited, 1=currently
            active and 2=done, but with the short circuit of breaking as soon
            as we find a loop (i.e. we meet another node, that is currently
            active).
        &#34;&#34;&#34;
        if statusMap[node] == 2:
            return False
        if statusMap[node] == 1:
            return True
        statusMap[node] = 1
        for n in node.children.values():
            if _cyclic(n):
                return True
        statusMap[node] = 2
        return False
    
    statusMap = {}
    for n in self.nodes.values():
        statusMap[n] = 0
    for n in self.nodes.values():
        if _cyclic(n):
            return False

    return True</code></pre>
</details>
</dd>
<dt id="ccbase.networks.Graph.is_ancestor"><code class="name flex">
<span>def <span class="ident">is_ancestor</span></span>(<span>self, node_a:Â Union[str,Â Node], node_b:Â Union[str,Â Node]) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if node_a is an ancestor of node_b.
Should also work in cyclic graphs!</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node_a</code></strong> :&ensp;<code>String</code></dt>
<dd>The name of the potential ancestor node.</dd>
<dt><strong><code>node_b</code></strong> :&ensp;<code>String</code></dt>
<dd>The name of the potential descendant node.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if node_a is an ancestor of node_b, False otherwise.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_ancestor(self, node_a: Union[str, Node], node_b: Union[str, Node]) -&gt; bool:
    &#34;&#34;&#34;
        Checks if node_a is an ancestor of node_b. 
        Should also work in cyclic graphs!

        Parameters
        ----------
        node_a: String
            The name of the potential ancestor node.
        node_b: String
            The name of the potential descendant node.

        Returns
        -------
        bool
            True if node_a is an ancestor of node_b, False otherwise.
    &#34;&#34;&#34;
    return node_a in self.get_ancestors(node_b)</code></pre>
</details>
</dd>
<dt id="ccbase.networks.Graph.is_descendant"><code class="name flex">
<span>def <span class="ident">is_descendant</span></span>(<span>self, node_a:Â Union[str,Â Node], node_b:Â Union[str,Â Node]) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if node_a is a descendant of node_b.
Should also work in cyclic graphs!</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node_a</code></strong> :&ensp;<code>String</code></dt>
<dd>The name of the potential descendant node.</dd>
<dt><strong><code>node_b</code></strong> :&ensp;<code>String</code></dt>
<dd>The name of the potential ancestor node.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if node_a is a descendant of node_b, False otherwise.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_descendant(self, node_a: Union[str, Node], node_b: Union[str, Node]) -&gt; bool:
    &#34;&#34;&#34;
        Checks if node_a is a descendant of node_b. 
        Should also work in cyclic graphs!

        Parameters
        ----------
        node_a: String
            The name of the potential descendant node.
        node_b: String
            The name of the potential ancestor node.

        Returns
        -------
        bool
            True if node_a is a descendant of node_b, False otherwise.
    &#34;&#34;&#34;
    return node_b in self.get_ancestors(node_a)</code></pre>
</details>
</dd>
<dt id="ccbase.networks.Graph.remove_edge"><code class="name flex">
<span>def <span class="ident">remove_edge</span></span>(<span>self, node1:Â Union[str,Â Node], node2:Â Union[str,Â Node])</span>
</code></dt>
<dd>
<div class="desc"><p>Removes an edge from node1 to node2, if it exists. Ignores incorrect
edges.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node1</code></strong> :&ensp;<code>String</code> or <code>Node</code></dt>
<dd>The name of the first node. The node object can also be used.</dd>
<dt><strong><code>node2</code></strong> :&ensp;<code>String</code> or <code>Node</code></dt>
<dd>The name of the second node. The node object can also be used.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>When either of the two nodes does not exist in the graph.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_edge(self, node1: Union[str, Node], node2: Union[str, Node]):
    &#34;&#34;&#34;
        Removes an edge from node1 to node2, if it exists. Ignores incorrect
        edges.
        
        Parameters
        ----------
        node1: String or Node
            The name of the first node. The node object can also be used.
        node2: String or Node
            The name of the second node. The node object can also be used.
        Raises
        ------
        ValueError
            When either of the two nodes does not exist in the graph.
    &#34;&#34;&#34;
    try:
        self.nodes[node1].remove_child(self.nodes[node2])
        self.nodes[node2].remove_parent(self.nodes[node1])
    except KeyError:
        raise ValueError(&#34;At least one of your specified nodes ({},{}) &#34; \
                         &#34;is not contained in the graph&#34;.format(node1, node2))</code></pre>
</details>
</dd>
<dt id="ccbase.networks.Graph.remove_node"><code class="name flex">
<span>def <span class="ident">remove_node</span></span>(<span>self, node:Â Union[str,Â Node])</span>
</code></dt>
<dd>
<div class="desc"><p>Removes the node with the given name from the graph.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>String</code> or <code>Node</code></dt>
<dd>The name of the new node or the node object itself.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_node(self, node: Union[str, Node]):
    &#34;&#34;&#34;
        Removes the node with the given name from the graph.
        
        Parameters
        ----------
        node: String or Node
            The name of the new node or the node object itself.
    &#34;&#34;&#34;
    if not node in self.nodes:
        raise ValueError(&#34;The graph does not contain a node named {}&#34;.format(node))
    
    self.nodes[node].destroy()
    del self.nodes[node]</code></pre>
</details>
</dd>
<dt id="ccbase.networks.Graph.to_undirected"><code class="name flex">
<span>def <span class="ident">to_undirected</span></span>(<span>self) â€‘>Â <a title="ccbase.networks.Graph" href="#ccbase.networks.Graph">Graph</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns an undirected copy this graph. Sine this implementation
does not really specify edge directions, we consider a bidrectional
graph as undirected!</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="ccbase.networks.Graph" href="#ccbase.networks.Graph">Graph</a></code></dt>
<dd>An undirected copy of this graph.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_undirected(self) -&gt; Graph:
    &#34;&#34;&#34;
        Returns an undirected copy this graph. Sine this implementation
        does not really specify edge directions, we consider a bidrectional
        graph as undirected!
        
        Returns
        -------
        Graph
            An undirected copy of this graph.
    &#34;&#34;&#34;
    res = self.copy()
    if res.is_directed:
        for n in res.nodes.values():
            for p in n.parents.values():
                n.add_child(p)
                p.add_parent(n)
            for c in n.children.values():
                c.add_child(n)
                n.add_parent(c)
        res.is_directed = False  
    return res</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ccbase" href="index.html">ccbase</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ccbase.networks.BayesianNetwork" href="#ccbase.networks.BayesianNetwork">BayesianNetwork</a></code></h4>
<ul class="">
<li><code><a title="ccbase.networks.BayesianNetwork.get_elimination_ordering" href="#ccbase.networks.BayesianNetwork.get_elimination_ordering">get_elimination_ordering</a></code></li>
<li><code><a title="ccbase.networks.BayesianNetwork.get_probability" href="#ccbase.networks.BayesianNetwork.get_probability">get_probability</a></code></li>
<li><code><a title="ccbase.networks.BayesianNetwork.marginals" href="#ccbase.networks.BayesianNetwork.marginals">marginals</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ccbase.networks.Graph" href="#ccbase.networks.Graph">Graph</a></code></h4>
<ul class="two-column">
<li><code><a title="ccbase.networks.Graph.add_edge" href="#ccbase.networks.Graph.add_edge">add_edge</a></code></li>
<li><code><a title="ccbase.networks.Graph.add_node" href="#ccbase.networks.Graph.add_node">add_node</a></code></li>
<li><code><a title="ccbase.networks.Graph.copy" href="#ccbase.networks.Graph.copy">copy</a></code></li>
<li><code><a title="ccbase.networks.Graph.get_ancestors" href="#ccbase.networks.Graph.get_ancestors">get_ancestors</a></code></li>
<li><code><a title="ccbase.networks.Graph.get_children" href="#ccbase.networks.Graph.get_children">get_children</a></code></li>
<li><code><a title="ccbase.networks.Graph.get_number_of_nodes" href="#ccbase.networks.Graph.get_number_of_nodes">get_number_of_nodes</a></code></li>
<li><code><a title="ccbase.networks.Graph.get_parents" href="#ccbase.networks.Graph.get_parents">get_parents</a></code></li>
<li><code><a title="ccbase.networks.Graph.is_acyclic" href="#ccbase.networks.Graph.is_acyclic">is_acyclic</a></code></li>
<li><code><a title="ccbase.networks.Graph.is_ancestor" href="#ccbase.networks.Graph.is_ancestor">is_ancestor</a></code></li>
<li><code><a title="ccbase.networks.Graph.is_descendant" href="#ccbase.networks.Graph.is_descendant">is_descendant</a></code></li>
<li><code><a title="ccbase.networks.Graph.remove_edge" href="#ccbase.networks.Graph.remove_edge">remove_edge</a></code></li>
<li><code><a title="ccbase.networks.Graph.remove_node" href="#ccbase.networks.Graph.remove_node">remove_node</a></code></li>
<li><code><a title="ccbase.networks.Graph.to_undirected" href="#ccbase.networks.Graph.to_undirected">to_undirected</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>