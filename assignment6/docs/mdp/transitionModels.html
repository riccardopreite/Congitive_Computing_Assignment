<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>mdp.transitionModels API documentation</title>
<meta name="description" content="Created on Thu Jul
6 11:06:50 2017
Module for different kinds of transition models. For now we only look at our
simple transition model described in …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>mdp.transitionModels</code></h1>
</header>
<section id="section-intro">
<p>Created on Thu Jul
6 11:06:50 2017
Module for different kinds of transition models. For now we only look at our
simple transition model described in the lecture and the assignment sheet.
@author: jpoeppel
Last modified: January, 12th 2022</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-
&#34;&#34;&#34;
Created on Thu Jul  6 11:06:50 2017
Module for different kinds of transition models. For now we only look at our
simple transition model described in the lecture and the assignment sheet.
@author: jpoeppel
Last modified: January, 12th 2022
&#34;&#34;&#34;
from __future__ import annotations
from typing import Optional, List, Tuple, Dict

import random

from .gridworld import Gridworld

__pdoc__ = {&#34;SimpleTransitionModel.__call__&#34;: True}

class SimpleTransitionModel(object):
    &#34;&#34;&#34;
        Represents a simple transition model which is constant for all 
        states in that the probability of reaching the next state with an
        action happens with probability accuracy. Deviations from the desired
        transition happens with the remaining probability, split according 
        to the specified ratio.
        See __call__ docs for details about how the actual probability is
        computed, especially with respect to running into walls.
    &#34;&#34;&#34;
    
    def __init__(self, accuracy: float, gridworld: Gridworld, ratio: Optional[float] = 0.5):
        self.accuracy = accuracy
        self.ratio = ratio
        self.world = gridworld

    def __call__(self, state: Tuple[int,int], action: str, new_state: Tuple[int,int]) -&gt; float:
        &#34;&#34;&#34;
            The __call__ overwrite allows to use the transitionModel object as a 
            function:
            
            tm = TransitionModel(0.8, environment) #Creates a new transitionModel

            prob = tm((1,1), &#34;N&#34;, (1,2)) #Queries the transition model for the
                                         #probability fo reaching state (1,2)
                                         #coming from state (1,1) with action &#34;N&#34;
            
            Returns the probability of reaching newState from state when
            trying to perform action, according to the gridworld provided
            in the constructor.
                        
            This follows the description on the assignment: When performing
            an action, it has a certain chance to succeed (given by the accuracy
            parameter specified in the constructor). When it does not 
            succeed, the agent moves to the adjacent directions instead, 
            but never in the completely opposite direction.
            The probabilities for the two possible accidental directions is
            given by the remaining probability (1-accuracy) and the specified
            ratio. The first accidental direction (which is clockwise direction)
            is given by (1-accuracy)*ratio while the other direction is given
            by the remaining probability: (1-accuracy)*(1-ratio).
            
            Example:
            accuracy = 0.8
            ratio = 0.2
            action = N
            
            Considering no walls: Reaching the state/tile directly above the
            current state, is 0.8, while the tile to the right of the current
            one has a probability of 0.2*0.2 = 0.04 and the tile to the left
            has a probability of 0.2*0.8 = 0.16.
            
            Any action (accidental or not) that would bumb into a wall (non-
            passable tile) remains in the initial state. Therefore the 
            probability of remaining in the current state sums up the 
            probabilities of the cases where the agent could voluntarily or
            accidental run into a wall.           
            
            
            Parameters
            ---------
            state: tuple
                The initial state.

            action: string
                One of the allowed actions N,S,E,W.

            new_state: tuple
                The resulting state.
                
            Returns
            -------
                float
                The probability of reaching the new state from the old one,
                using the given action.
        &#34;&#34;&#34;
        
        if action == &#34;E&#34;:
            true_new = (state[0]+1, state[1])
            acc1 = (state[0], state[1]-1)
            acc2 = (state[0], state[1]+1)
        elif action == &#34;W&#34;:
            true_new = (state[0]-1, state[1])
            acc1 = (state[0], state[1]+1)
            acc2 = (state[0], state[1]-1)
        elif action == &#34;N&#34;:
            true_new = (state[0], state[1]+1)
            acc1 = (state[0]+1, state[1])
            acc2 = (state[0]-1, state[1])
        elif action == &#34;S&#34;:
            true_new = (state[0], state[1]-1)
            acc1 = (state[0]-1, state[1])
            acc2 = (state[0]+1, state[1])
        else:
            raise ValueError(&#34;Unknown action: {}&#34;.format(action))
            
        resProb = 0
        if self.world.check_passable(new_state):
            # We add our accuracy probability when the new desired state has
            # actually been reached, or by following that action we run into a wall.
            if true_new == new_state or (new_state == state and \
                    not self.world.check_passable(true_new)):
                resProb += self.accuracy
                
            # If we reach an accidantal state, we add (1-noise)*ratio for the 
            # first accident
            # we also add this if the accidental state would run into a wall
            if new_state == acc1 or (new_state == state and \
                     not self.world.check_passable(acc1)):
                resProb += (1-self.accuracy)*self.ratio
                
            # If we reach an accidantal state, we add the remaining 
            # probability [ (1-noise)*(1-ratio)] for the second accident
            # we also add this if the accidental state would run into a wall    
            if new_state == acc2 or (new_state == state and \
                     not self.world.check_passable(acc2)):
                resProb += (1-self.accuracy)*(1-self.ratio)
            
        return resProb

    
    def sample_action(self, state: Tuple[int,int], action: str) -&gt; str:
        &#34;&#34;&#34;
            Samples the action the agent actually performs when he tries to
            perform the given action. Does not yet produce the actual effect,
            as this will depend on the environment (e.g. does the agent
            run into a wall). Hard codes our model of inaccuracy.
            
            Parameters
            ---------
            state: tuple
                The current state of the agent. Is ignored in this case since
                we have a constant transition probability.
            
            action: String
                The intended action.
                
            Returns
            -------
            String
                The action that will be performed.
        &#34;&#34;&#34;
        u = random.random()
        if u &lt;= self.accuracy:
            return action
        else:
            if u &lt;= self.accuracy+(1-self.accuracy)*self.ratio:
                acc1 = True
            else:
                acc1 = False
                
            if action == &#34;N&#34;:
                if acc1:
                    return &#34;E&#34;
                else:
                    return &#34;W&#34;
            if action == &#34;S&#34;:
                if acc1:
                    return &#34;W&#34;
                else:
                    return &#34;E&#34;
            if action == &#34;E&#34;:
                if acc1:
                    return &#34;S&#34;
                else:
                    return &#34;N&#34;
            if action == &#34;W&#34;:
                if acc1:
                    return &#34;N&#34;
                else:
                    return &#34;S&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="mdp.transitionModels.SimpleTransitionModel"><code class="flex name class">
<span>class <span class="ident">SimpleTransitionModel</span></span>
<span>(</span><span>accuracy: float, gridworld: Gridworld, ratio: Optional[float] = 0.5)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a simple transition model which is constant for all
states in that the probability of reaching the next state with an
action happens with probability accuracy. Deviations from the desired
transition happens with the remaining probability, split according
to the specified ratio.
See <strong>call</strong> docs for details about how the actual probability is
computed, especially with respect to running into walls.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SimpleTransitionModel(object):
    &#34;&#34;&#34;
        Represents a simple transition model which is constant for all 
        states in that the probability of reaching the next state with an
        action happens with probability accuracy. Deviations from the desired
        transition happens with the remaining probability, split according 
        to the specified ratio.
        See __call__ docs for details about how the actual probability is
        computed, especially with respect to running into walls.
    &#34;&#34;&#34;
    
    def __init__(self, accuracy: float, gridworld: Gridworld, ratio: Optional[float] = 0.5):
        self.accuracy = accuracy
        self.ratio = ratio
        self.world = gridworld

    def __call__(self, state: Tuple[int,int], action: str, new_state: Tuple[int,int]) -&gt; float:
        &#34;&#34;&#34;
            The __call__ overwrite allows to use the transitionModel object as a 
            function:
            
            tm = TransitionModel(0.8, environment) #Creates a new transitionModel

            prob = tm((1,1), &#34;N&#34;, (1,2)) #Queries the transition model for the
                                         #probability fo reaching state (1,2)
                                         #coming from state (1,1) with action &#34;N&#34;
            
            Returns the probability of reaching newState from state when
            trying to perform action, according to the gridworld provided
            in the constructor.
                        
            This follows the description on the assignment: When performing
            an action, it has a certain chance to succeed (given by the accuracy
            parameter specified in the constructor). When it does not 
            succeed, the agent moves to the adjacent directions instead, 
            but never in the completely opposite direction.
            The probabilities for the two possible accidental directions is
            given by the remaining probability (1-accuracy) and the specified
            ratio. The first accidental direction (which is clockwise direction)
            is given by (1-accuracy)*ratio while the other direction is given
            by the remaining probability: (1-accuracy)*(1-ratio).
            
            Example:
            accuracy = 0.8
            ratio = 0.2
            action = N
            
            Considering no walls: Reaching the state/tile directly above the
            current state, is 0.8, while the tile to the right of the current
            one has a probability of 0.2*0.2 = 0.04 and the tile to the left
            has a probability of 0.2*0.8 = 0.16.
            
            Any action (accidental or not) that would bumb into a wall (non-
            passable tile) remains in the initial state. Therefore the 
            probability of remaining in the current state sums up the 
            probabilities of the cases where the agent could voluntarily or
            accidental run into a wall.           
            
            
            Parameters
            ---------
            state: tuple
                The initial state.

            action: string
                One of the allowed actions N,S,E,W.

            new_state: tuple
                The resulting state.
                
            Returns
            -------
                float
                The probability of reaching the new state from the old one,
                using the given action.
        &#34;&#34;&#34;
        
        if action == &#34;E&#34;:
            true_new = (state[0]+1, state[1])
            acc1 = (state[0], state[1]-1)
            acc2 = (state[0], state[1]+1)
        elif action == &#34;W&#34;:
            true_new = (state[0]-1, state[1])
            acc1 = (state[0], state[1]+1)
            acc2 = (state[0], state[1]-1)
        elif action == &#34;N&#34;:
            true_new = (state[0], state[1]+1)
            acc1 = (state[0]+1, state[1])
            acc2 = (state[0]-1, state[1])
        elif action == &#34;S&#34;:
            true_new = (state[0], state[1]-1)
            acc1 = (state[0]-1, state[1])
            acc2 = (state[0]+1, state[1])
        else:
            raise ValueError(&#34;Unknown action: {}&#34;.format(action))
            
        resProb = 0
        if self.world.check_passable(new_state):
            # We add our accuracy probability when the new desired state has
            # actually been reached, or by following that action we run into a wall.
            if true_new == new_state or (new_state == state and \
                    not self.world.check_passable(true_new)):
                resProb += self.accuracy
                
            # If we reach an accidantal state, we add (1-noise)*ratio for the 
            # first accident
            # we also add this if the accidental state would run into a wall
            if new_state == acc1 or (new_state == state and \
                     not self.world.check_passable(acc1)):
                resProb += (1-self.accuracy)*self.ratio
                
            # If we reach an accidantal state, we add the remaining 
            # probability [ (1-noise)*(1-ratio)] for the second accident
            # we also add this if the accidental state would run into a wall    
            if new_state == acc2 or (new_state == state and \
                     not self.world.check_passable(acc2)):
                resProb += (1-self.accuracy)*(1-self.ratio)
            
        return resProb

    
    def sample_action(self, state: Tuple[int,int], action: str) -&gt; str:
        &#34;&#34;&#34;
            Samples the action the agent actually performs when he tries to
            perform the given action. Does not yet produce the actual effect,
            as this will depend on the environment (e.g. does the agent
            run into a wall). Hard codes our model of inaccuracy.
            
            Parameters
            ---------
            state: tuple
                The current state of the agent. Is ignored in this case since
                we have a constant transition probability.
            
            action: String
                The intended action.
                
            Returns
            -------
            String
                The action that will be performed.
        &#34;&#34;&#34;
        u = random.random()
        if u &lt;= self.accuracy:
            return action
        else:
            if u &lt;= self.accuracy+(1-self.accuracy)*self.ratio:
                acc1 = True
            else:
                acc1 = False
                
            if action == &#34;N&#34;:
                if acc1:
                    return &#34;E&#34;
                else:
                    return &#34;W&#34;
            if action == &#34;S&#34;:
                if acc1:
                    return &#34;W&#34;
                else:
                    return &#34;E&#34;
            if action == &#34;E&#34;:
                if acc1:
                    return &#34;S&#34;
                else:
                    return &#34;N&#34;
            if action == &#34;W&#34;:
                if acc1:
                    return &#34;N&#34;
                else:
                    return &#34;S&#34;</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="mdp.transitionModels.SimpleTransitionModel.__call__"><code class="name flex">
<span>def <span class="ident">__call__</span></span>(<span>self, state: Tuple[int, int], action: str, new_state: Tuple[int, int]) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>The <strong>call</strong> overwrite allows to use the transitionModel object as a
function:</p>
<p>tm = TransitionModel(0.8, environment) #Creates a new transitionModel</p>
<p>prob = tm((1,1), "N", (1,2)) #Queries the transition model for the
#probability fo reaching state (1,2)
#coming from state (1,1) with action "N"</p>
<p>Returns the probability of reaching newState from state when
trying to perform action, according to the gridworld provided
in the constructor.</p>
<p>This follows the description on the assignment: When performing
an action, it has a certain chance to succeed (given by the accuracy
parameter specified in the constructor). When it does not
succeed, the agent moves to the adjacent directions instead,
but never in the completely opposite direction.
The probabilities for the two possible accidental directions is
given by the remaining probability (1-accuracy) and the specified
ratio. The first accidental direction (which is clockwise direction)
is given by (1-accuracy)<em>ratio while the other direction is given
by the remaining probability: (1-accuracy)</em>(1-ratio).</p>
<p>Example:
accuracy = 0.8
ratio = 0.2
action = N</p>
<p>Considering no walls: Reaching the state/tile directly above the
current state, is 0.8, while the tile to the right of the current
one has a probability of 0.2<em>0.2 = 0.04 and the tile to the left
has a probability of 0.2</em>0.8 = 0.16.</p>
<p>Any action (accidental or not) that would bumb into a wall (non-
passable tile) remains in the initial state. Therefore the
probability of remaining in the current state sums up the
probabilities of the cases where the agent could voluntarily or
accidental run into a wall.
</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The initial state.</dd>
<dt><strong><code>action</code></strong> :&ensp;<code>string</code></dt>
<dd>One of the allowed actions N,S,E,W.</dd>
<dt><strong><code>new_state</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The resulting state.</dd>
</dl>
<h2 id="returns">Returns</h2>
<pre><code>float
The probability of reaching the new state from the old one,
using the given action.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __call__(self, state: Tuple[int,int], action: str, new_state: Tuple[int,int]) -&gt; float:
    &#34;&#34;&#34;
        The __call__ overwrite allows to use the transitionModel object as a 
        function:
        
        tm = TransitionModel(0.8, environment) #Creates a new transitionModel

        prob = tm((1,1), &#34;N&#34;, (1,2)) #Queries the transition model for the
                                     #probability fo reaching state (1,2)
                                     #coming from state (1,1) with action &#34;N&#34;
        
        Returns the probability of reaching newState from state when
        trying to perform action, according to the gridworld provided
        in the constructor.
                    
        This follows the description on the assignment: When performing
        an action, it has a certain chance to succeed (given by the accuracy
        parameter specified in the constructor). When it does not 
        succeed, the agent moves to the adjacent directions instead, 
        but never in the completely opposite direction.
        The probabilities for the two possible accidental directions is
        given by the remaining probability (1-accuracy) and the specified
        ratio. The first accidental direction (which is clockwise direction)
        is given by (1-accuracy)*ratio while the other direction is given
        by the remaining probability: (1-accuracy)*(1-ratio).
        
        Example:
        accuracy = 0.8
        ratio = 0.2
        action = N
        
        Considering no walls: Reaching the state/tile directly above the
        current state, is 0.8, while the tile to the right of the current
        one has a probability of 0.2*0.2 = 0.04 and the tile to the left
        has a probability of 0.2*0.8 = 0.16.
        
        Any action (accidental or not) that would bumb into a wall (non-
        passable tile) remains in the initial state. Therefore the 
        probability of remaining in the current state sums up the 
        probabilities of the cases where the agent could voluntarily or
        accidental run into a wall.           
        
        
        Parameters
        ---------
        state: tuple
            The initial state.

        action: string
            One of the allowed actions N,S,E,W.

        new_state: tuple
            The resulting state.
            
        Returns
        -------
            float
            The probability of reaching the new state from the old one,
            using the given action.
    &#34;&#34;&#34;
    
    if action == &#34;E&#34;:
        true_new = (state[0]+1, state[1])
        acc1 = (state[0], state[1]-1)
        acc2 = (state[0], state[1]+1)
    elif action == &#34;W&#34;:
        true_new = (state[0]-1, state[1])
        acc1 = (state[0], state[1]+1)
        acc2 = (state[0], state[1]-1)
    elif action == &#34;N&#34;:
        true_new = (state[0], state[1]+1)
        acc1 = (state[0]+1, state[1])
        acc2 = (state[0]-1, state[1])
    elif action == &#34;S&#34;:
        true_new = (state[0], state[1]-1)
        acc1 = (state[0]-1, state[1])
        acc2 = (state[0]+1, state[1])
    else:
        raise ValueError(&#34;Unknown action: {}&#34;.format(action))
        
    resProb = 0
    if self.world.check_passable(new_state):
        # We add our accuracy probability when the new desired state has
        # actually been reached, or by following that action we run into a wall.
        if true_new == new_state or (new_state == state and \
                not self.world.check_passable(true_new)):
            resProb += self.accuracy
            
        # If we reach an accidantal state, we add (1-noise)*ratio for the 
        # first accident
        # we also add this if the accidental state would run into a wall
        if new_state == acc1 or (new_state == state and \
                 not self.world.check_passable(acc1)):
            resProb += (1-self.accuracy)*self.ratio
            
        # If we reach an accidantal state, we add the remaining 
        # probability [ (1-noise)*(1-ratio)] for the second accident
        # we also add this if the accidental state would run into a wall    
        if new_state == acc2 or (new_state == state and \
                 not self.world.check_passable(acc2)):
            resProb += (1-self.accuracy)*(1-self.ratio)
        
    return resProb</code></pre>
</details>
</dd>
<dt id="mdp.transitionModels.SimpleTransitionModel.sample_action"><code class="name flex">
<span>def <span class="ident">sample_action</span></span>(<span>self, state: Tuple[int, int], action: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Samples the action the agent actually performs when he tries to
perform the given action. Does not yet produce the actual effect,
as this will depend on the environment (e.g. does the agent
run into a wall). Hard codes our model of inaccuracy.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The current state of the agent. Is ignored in this case since
we have a constant transition probability.</dd>
<dt><strong><code>action</code></strong> :&ensp;<code>String</code></dt>
<dd>The intended action.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>String</code></dt>
<dd>The action that will be performed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_action(self, state: Tuple[int,int], action: str) -&gt; str:
    &#34;&#34;&#34;
        Samples the action the agent actually performs when he tries to
        perform the given action. Does not yet produce the actual effect,
        as this will depend on the environment (e.g. does the agent
        run into a wall). Hard codes our model of inaccuracy.
        
        Parameters
        ---------
        state: tuple
            The current state of the agent. Is ignored in this case since
            we have a constant transition probability.
        
        action: String
            The intended action.
            
        Returns
        -------
        String
            The action that will be performed.
    &#34;&#34;&#34;
    u = random.random()
    if u &lt;= self.accuracy:
        return action
    else:
        if u &lt;= self.accuracy+(1-self.accuracy)*self.ratio:
            acc1 = True
        else:
            acc1 = False
            
        if action == &#34;N&#34;:
            if acc1:
                return &#34;E&#34;
            else:
                return &#34;W&#34;
        if action == &#34;S&#34;:
            if acc1:
                return &#34;W&#34;
            else:
                return &#34;E&#34;
        if action == &#34;E&#34;:
            if acc1:
                return &#34;S&#34;
            else:
                return &#34;N&#34;
        if action == &#34;W&#34;:
            if acc1:
                return &#34;N&#34;
            else:
                return &#34;S&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="mdp" href="index.html">mdp</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="mdp.transitionModels.SimpleTransitionModel" href="#mdp.transitionModels.SimpleTransitionModel">SimpleTransitionModel</a></code></h4>
<ul class="">
<li><code><a title="mdp.transitionModels.SimpleTransitionModel.__call__" href="#mdp.transitionModels.SimpleTransitionModel.__call__">__call__</a></code></li>
<li><code><a title="mdp.transitionModels.SimpleTransitionModel.sample_action" href="#mdp.transitionModels.SimpleTransitionModel.sample_action">sample_action</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>