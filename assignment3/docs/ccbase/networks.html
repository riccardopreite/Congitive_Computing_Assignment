<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ccbase.networks API documentation</title>
<meta name="description" content="Created on Thu Apr 27 13:46:30 2017
Refactored module for holding graphical networks. At this point we only
need our graph class and its subclass for â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ccbase.networks</code></h1>
</header>
<section id="section-intro">
<p>Created on Thu Apr 27 13:46:30 2017
Refactored module for holding graphical networks. At this point we only
need our graph class and its subclass for Bayesian networks.
@author: jpoeppel</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-
&#34;&#34;&#34;
Created on Thu Apr 27 13:46:30 2017
Refactored module for holding graphical networks. At this point we only
need our graph class and its subclass for Bayesian networks.
@author: jpoeppel
&#34;&#34;&#34;
from __future__ import annotations
import copy
from typing import Union, Optional, List, Dict, Iterable

from .nodes import Node

import numpy as np

class Graph:
    
    def __init__(self):
        self.nodes = {}
        
    def add_node(self, node: Union[str, Node]):
        &#34;&#34;&#34;
            Adds a node to the graph. Will first create a new node object
            with the given name.
            
            Parameters
            ----------
            node: String or Node
                The name of the new node or the new node directly. In case
                a string is passed, a new node will be created before adding it.
        &#34;&#34;&#34;
        if node in self.nodes:
            raise ValueError(&#34;The graph already contains a node named {}&#34;.format(node))
        
        try:
            self.nodes[node.name] = node
        except AttributeError: #We check for an attribute, rather than a type.
            self.nodes[node] = Node(node)
        
    def remove_node(self, node: Union[str, Node]):
        &#34;&#34;&#34;
            Removes the node with the given name from the graph.
            
            Parameters
            ----------
            node: String or Node
                The name of the new node or the node object itself.
        &#34;&#34;&#34;
        if not node in self.nodes:
            raise ValueError(&#34;The graph does not contain a node named {}&#34;.format(node))
        
        self.nodes[node].destroy()
        del self.nodes[node]
        
    def add_edge(self, node1: Union[str, Node], node2: Union[str, Node]):
        &#34;&#34;&#34;
            Adds a directed edge from node1 to node2. In this implementation, edges
            are only implictly represented, via parent and child relations in the
            nodes. One could alternatively explicitly represent edge objects that
            connect nodes.
            
            Parameters
            ----------
            node1: String or Node
                The name of the first node. The node object can also be used.
            node2: String or Node
                The name of the second node. The node object can also be used.

            Raises
            ------
            ValueError
                When either of the two nodes does not exist in the graph.
        &#34;&#34;&#34;
        try:
            self.nodes[node1].add_child(self.nodes[node2])
            self.nodes[node2].add_parent(self.nodes[node1])
        except KeyError:
            raise ValueError(&#34;At least one of your specified nodes ({},{}) &#34; \
                             &#34;is not contained in the graph&#34;.format(node1, node2))
            
    def remove_edge(self, node1: Union[str, Node], node2: Union[str, Node]):
        &#34;&#34;&#34;
            Removes an edge from node1 to node2, if it exists. Ignores incorrect
            edges.
            
            Parameters
            ----------
            node1: String or Node
                The name of the first node. The node object can also be used.
            node2: String or Node
                The name of the second node. The node object can also be used.
            Raises
            ------
            ValueError
                When either of the two nodes does not exist in the graph.
        &#34;&#34;&#34;
        try:
            self.nodes[node1].remove_child(self.nodes[node2])
            self.nodes[node2].remove_parent(self.nodes[node1])
        except KeyError:
            raise ValueError(&#34;At least one of your specified nodes ({},{}) &#34; \
                             &#34;is not contained in the graph&#34;.format(node1, node2))
            
    def get_number_of_nodes(self) -&gt; int:
        &#34;&#34;&#34;
            Returns
            -------
            int
                The total number of nodes in the graph.
        &#34;&#34;&#34;
        return len(self.nodes)

    @property
    def num_nodes(self) -&gt; int:
        &#34;&#34;&#34;
            Performs the same as &#34;get_number_of_nodes&#34; but as a property.

            Returns
            -------
            int
                The total number of nodes in the graph.
        &#34;&#34;&#34;
        return len(self.nodes)
    
    def get_parents(self, node: Union[str, Node]) -&gt; List[Node]:
        &#34;&#34;&#34;
            Parameters
            ----------
            node: String or Node
                The name of the node whose parents are queried.
                The Node object itself can also be used.
                
            Returns
            -------
            list
                A list containing all parent nodes of the specified node.
                Be careful that these are the actual node objects contained in
                the graph, NOT copies!

            Raises
            ------
            ValueError
                When the graph does not contain the queried node.
        &#34;&#34;&#34;
        try:
            return list(self.nodes[node].parents.values())
        except KeyError:
            raise ValueError(&#34;The graph does not contain a node called {}&#34;.format(node))
            
    def get_children(self, node: Union[str, Node]) -&gt; List[Node]:
        &#34;&#34;&#34;
            Parameters
            ----------
            node: String
                The name of the node whose children are queried.
                The Node object itself can also be used.
                
            Returns
            -------
            list
                A list containing all children nodes of the specified node.
                Be careful that these are the actual node objects contained in
                the graph, NOT copies!

            Raises
            ------
            ValueError
                When the graph does not contain the queried node.
        &#34;&#34;&#34;
        try:
            return list(self.nodes[node].children.values())
        except KeyError:
            raise ValueError(&#34;The graph does not contain a node called {}&#34;.format(node)) 
            
    def get_ancestors(self, node: Union[str, Node]) -&gt; List[Node]:
        &#34;&#34;&#34;
            Parameters
            ----------
            node: String or Node
                The name of the node whose ancestors are queried.
                The Node object itself can also be used.
                
            Returns
            -------
            set
                A set containing all ancestor nodes of the specified node.
                Be careful that these are the actual node objects contained in
                the graph, NOT copies!

            Raises
            ------
            ValueError
                When the graph does not contain the queried node.
        &#34;&#34;&#34;
        if not node in self.nodes:
            raise ValueError(&#34;The graph does not contain a node called {}&#34;.format(node))
        def _add_parents(tmpNode):
            for p in tmpNode.parents.values():
                if p in res:
                    continue
                res.add(p)
                _add_parents(p)
        res = set()
        _add_parents(self.nodes[node])
        return res

    def is_ancestor(self, node_a: Union[str, Node], node_b: Union[str, Node]) -&gt; bool:
        &#34;&#34;&#34;
            Checks if node_a is an ancestor of node_b. 
            Should also work in cyclic graphs!

            Parameters
            ----------
            node_a: String
                The name of the potential ancestor node.
            node_b: String
                The name of the potential descendant node.

            Returns
            -------
                bool
                True if node_a is an ancestor of node_b, False otherwise.
        &#34;&#34;&#34;
        return node_a in self.get_ancestors(node_b)

    def get_descendants(self, node: Union[str, Node]) -&gt; List[Node]:
        &#34;&#34;&#34;
            Parameters
            ----------
            node: String or `ccbase.nodes.Node`
                The name of the node whose descendants are queried.
                
            Returns
            -------
            set
                A set containing all descendant nodes of the specified node.
        &#34;&#34;&#34;
        def _add_children(tmp_node):
            for p in tmp_node.children.values():
                if p in res:
                    continue
                res.add(p)
                _add_children(p)
        res = set()
        _add_children(self.nodes[node])
        return res
  

    def is_descendant(self, node_a: Union[str, Node], node_b: Union[str, Node]) -&gt; bool:
        &#34;&#34;&#34;
            Checks if node_a is a descendant of node_b. 
            Should also work in cyclic graphs!

            Parameters
            ----------
            node_a: String
                The name of the potential descendant node.
            node_b: String
                The name of the potential ancestor node.

            Returns
            -------
            bool
                True if node_a is a descendant of node_b, False otherwise.
        &#34;&#34;&#34;
        return node_b in self.get_ancestors(node_a)

    def is_acyclic(self) -&gt; bool:
        &#34;&#34;&#34;
            Computes whether or not this graph is acyclic.
        
            Returns
            ----------
            bool
                True if there are no cycles within the provided graph, False otherwise.
        &#34;&#34;&#34;
        def _cyclic(node):
            &#34;&#34;&#34;
                Private helper function to check if a node is cyclic.
                
                This basically implements a marking/painting algorithm going over all
                nodes and marking them according to 0=not yet visited, 1=currently
                active and 2=done, but with the short circuit of breaking as soon
                as we find a loop (i.e. we meet another node, that is currently
                active).
            &#34;&#34;&#34;
            if statusMap[node] == 2:
                return False
            if statusMap[node] == 1:
                return True
            statusMap[node] = 1
            for n in node.children.values():
                if _cyclic(n):
                    return True
            statusMap[node] = 2
            return False
        
        statusMap = {}
        for n in self.nodes.values():
            statusMap[n] = 0
        for n in self.nodes.values():
            if _cyclic(n):
                return False

        return True
            
    def copy(self, deep=True) -&gt; Graph:
        &#34;&#34;&#34;
            Copies the current graph.
            
            Parameters
            ----------
            deep: Bool
                If true, a deep copy will be performed, i.e. all nodes are also
                copied. In a shallow copy, both graph instances will contain the
                same node references.
            
            Returns
            -------
            Graph
                Creates a (deep) copy of this graph.
        &#34;&#34;&#34;
       
        if deep:
            return copy.deepcopy(self)
        else:
             return copy.copy(self)

    @property
    def is_directed(self) -&gt; bool:
        &#34;&#34;&#34;
            A property checking if this graph is directed in the 
            sense that there is only a directed edge between any two
            connected nodes. If any node is connected with a neighbor
            in both directions it is considered an undirected graph.
            A return of &#34;False&#34; here could mean an undirected graph, or
            a &#34;broken&#34; graph, not all edges are checked in that case.

            Returns
            -------
            bool
                True if there are only single connections between two
                connected nodes, False otherwise.
                False does **NOT** directly mean that this is a correct
                undirected graph! 
        &#34;&#34;&#34;
        for n in self.nodes.values():
            for c in n.children.values():
                if c in n.parents:
                    return False
        return True
            
    def to_undirected(self) -&gt; Graph:
        &#34;&#34;&#34;
            Returns an undirected copy this graph. Sine this implementation
            does not really specify edge directions, we consider a bidrectional
            graph as undirected!
            
            Returns
            -------
            Graph
                An undirected copy of this graph.
        &#34;&#34;&#34;
        res = self.copy()
        # if res.is_directed: # This could be a shortcut, but since False does not 
        # guarantee a correct undirected graph, it is safer this way
        for n in res.nodes.values():
            for p in n.parents.values():
                n.add_child(p)
                p.add_parent(n)
            for c in n.children.values():
                c.add_child(n)
                n.add_parent(c)
        return res
        
        </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ccbase.networks.Graph"><code class="flex name class">
<span>class <span class="ident">Graph</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Graph:
    
    def __init__(self):
        self.nodes = {}
        
    def add_node(self, node: Union[str, Node]):
        &#34;&#34;&#34;
            Adds a node to the graph. Will first create a new node object
            with the given name.
            
            Parameters
            ----------
            node: String or Node
                The name of the new node or the new node directly. In case
                a string is passed, a new node will be created before adding it.
        &#34;&#34;&#34;
        if node in self.nodes:
            raise ValueError(&#34;The graph already contains a node named {}&#34;.format(node))
        
        try:
            self.nodes[node.name] = node
        except AttributeError: #We check for an attribute, rather than a type.
            self.nodes[node] = Node(node)
        
    def remove_node(self, node: Union[str, Node]):
        &#34;&#34;&#34;
            Removes the node with the given name from the graph.
            
            Parameters
            ----------
            node: String or Node
                The name of the new node or the node object itself.
        &#34;&#34;&#34;
        if not node in self.nodes:
            raise ValueError(&#34;The graph does not contain a node named {}&#34;.format(node))
        
        self.nodes[node].destroy()
        del self.nodes[node]
        
    def add_edge(self, node1: Union[str, Node], node2: Union[str, Node]):
        &#34;&#34;&#34;
            Adds a directed edge from node1 to node2. In this implementation, edges
            are only implictly represented, via parent and child relations in the
            nodes. One could alternatively explicitly represent edge objects that
            connect nodes.
            
            Parameters
            ----------
            node1: String or Node
                The name of the first node. The node object can also be used.
            node2: String or Node
                The name of the second node. The node object can also be used.

            Raises
            ------
            ValueError
                When either of the two nodes does not exist in the graph.
        &#34;&#34;&#34;
        try:
            self.nodes[node1].add_child(self.nodes[node2])
            self.nodes[node2].add_parent(self.nodes[node1])
        except KeyError:
            raise ValueError(&#34;At least one of your specified nodes ({},{}) &#34; \
                             &#34;is not contained in the graph&#34;.format(node1, node2))
            
    def remove_edge(self, node1: Union[str, Node], node2: Union[str, Node]):
        &#34;&#34;&#34;
            Removes an edge from node1 to node2, if it exists. Ignores incorrect
            edges.
            
            Parameters
            ----------
            node1: String or Node
                The name of the first node. The node object can also be used.
            node2: String or Node
                The name of the second node. The node object can also be used.
            Raises
            ------
            ValueError
                When either of the two nodes does not exist in the graph.
        &#34;&#34;&#34;
        try:
            self.nodes[node1].remove_child(self.nodes[node2])
            self.nodes[node2].remove_parent(self.nodes[node1])
        except KeyError:
            raise ValueError(&#34;At least one of your specified nodes ({},{}) &#34; \
                             &#34;is not contained in the graph&#34;.format(node1, node2))
            
    def get_number_of_nodes(self) -&gt; int:
        &#34;&#34;&#34;
            Returns
            -------
            int
                The total number of nodes in the graph.
        &#34;&#34;&#34;
        return len(self.nodes)

    @property
    def num_nodes(self) -&gt; int:
        &#34;&#34;&#34;
            Performs the same as &#34;get_number_of_nodes&#34; but as a property.

            Returns
            -------
            int
                The total number of nodes in the graph.
        &#34;&#34;&#34;
        return len(self.nodes)
    
    def get_parents(self, node: Union[str, Node]) -&gt; List[Node]:
        &#34;&#34;&#34;
            Parameters
            ----------
            node: String or Node
                The name of the node whose parents are queried.
                The Node object itself can also be used.
                
            Returns
            -------
            list
                A list containing all parent nodes of the specified node.
                Be careful that these are the actual node objects contained in
                the graph, NOT copies!

            Raises
            ------
            ValueError
                When the graph does not contain the queried node.
        &#34;&#34;&#34;
        try:
            return list(self.nodes[node].parents.values())
        except KeyError:
            raise ValueError(&#34;The graph does not contain a node called {}&#34;.format(node))
            
    def get_children(self, node: Union[str, Node]) -&gt; List[Node]:
        &#34;&#34;&#34;
            Parameters
            ----------
            node: String
                The name of the node whose children are queried.
                The Node object itself can also be used.
                
            Returns
            -------
            list
                A list containing all children nodes of the specified node.
                Be careful that these are the actual node objects contained in
                the graph, NOT copies!

            Raises
            ------
            ValueError
                When the graph does not contain the queried node.
        &#34;&#34;&#34;
        try:
            return list(self.nodes[node].children.values())
        except KeyError:
            raise ValueError(&#34;The graph does not contain a node called {}&#34;.format(node)) 
            
    def get_ancestors(self, node: Union[str, Node]) -&gt; List[Node]:
        &#34;&#34;&#34;
            Parameters
            ----------
            node: String or Node
                The name of the node whose ancestors are queried.
                The Node object itself can also be used.
                
            Returns
            -------
            set
                A set containing all ancestor nodes of the specified node.
                Be careful that these are the actual node objects contained in
                the graph, NOT copies!

            Raises
            ------
            ValueError
                When the graph does not contain the queried node.
        &#34;&#34;&#34;
        if not node in self.nodes:
            raise ValueError(&#34;The graph does not contain a node called {}&#34;.format(node))
        def _add_parents(tmpNode):
            for p in tmpNode.parents.values():
                if p in res:
                    continue
                res.add(p)
                _add_parents(p)
        res = set()
        _add_parents(self.nodes[node])
        return res

    def is_ancestor(self, node_a: Union[str, Node], node_b: Union[str, Node]) -&gt; bool:
        &#34;&#34;&#34;
            Checks if node_a is an ancestor of node_b. 
            Should also work in cyclic graphs!

            Parameters
            ----------
            node_a: String
                The name of the potential ancestor node.
            node_b: String
                The name of the potential descendant node.

            Returns
            -------
                bool
                True if node_a is an ancestor of node_b, False otherwise.
        &#34;&#34;&#34;
        return node_a in self.get_ancestors(node_b)

    def get_descendants(self, node: Union[str, Node]) -&gt; List[Node]:
        &#34;&#34;&#34;
            Parameters
            ----------
            node: String or `ccbase.nodes.Node`
                The name of the node whose descendants are queried.
                
            Returns
            -------
            set
                A set containing all descendant nodes of the specified node.
        &#34;&#34;&#34;
        def _add_children(tmp_node):
            for p in tmp_node.children.values():
                if p in res:
                    continue
                res.add(p)
                _add_children(p)
        res = set()
        _add_children(self.nodes[node])
        return res
  

    def is_descendant(self, node_a: Union[str, Node], node_b: Union[str, Node]) -&gt; bool:
        &#34;&#34;&#34;
            Checks if node_a is a descendant of node_b. 
            Should also work in cyclic graphs!

            Parameters
            ----------
            node_a: String
                The name of the potential descendant node.
            node_b: String
                The name of the potential ancestor node.

            Returns
            -------
            bool
                True if node_a is a descendant of node_b, False otherwise.
        &#34;&#34;&#34;
        return node_b in self.get_ancestors(node_a)

    def is_acyclic(self) -&gt; bool:
        &#34;&#34;&#34;
            Computes whether or not this graph is acyclic.
        
            Returns
            ----------
            bool
                True if there are no cycles within the provided graph, False otherwise.
        &#34;&#34;&#34;
        def _cyclic(node):
            &#34;&#34;&#34;
                Private helper function to check if a node is cyclic.
                
                This basically implements a marking/painting algorithm going over all
                nodes and marking them according to 0=not yet visited, 1=currently
                active and 2=done, but with the short circuit of breaking as soon
                as we find a loop (i.e. we meet another node, that is currently
                active).
            &#34;&#34;&#34;
            if statusMap[node] == 2:
                return False
            if statusMap[node] == 1:
                return True
            statusMap[node] = 1
            for n in node.children.values():
                if _cyclic(n):
                    return True
            statusMap[node] = 2
            return False
        
        statusMap = {}
        for n in self.nodes.values():
            statusMap[n] = 0
        for n in self.nodes.values():
            if _cyclic(n):
                return False

        return True
            
    def copy(self, deep=True) -&gt; Graph:
        &#34;&#34;&#34;
            Copies the current graph.
            
            Parameters
            ----------
            deep: Bool
                If true, a deep copy will be performed, i.e. all nodes are also
                copied. In a shallow copy, both graph instances will contain the
                same node references.
            
            Returns
            -------
            Graph
                Creates a (deep) copy of this graph.
        &#34;&#34;&#34;
       
        if deep:
            return copy.deepcopy(self)
        else:
             return copy.copy(self)

    @property
    def is_directed(self) -&gt; bool:
        &#34;&#34;&#34;
            A property checking if this graph is directed in the 
            sense that there is only a directed edge between any two
            connected nodes. If any node is connected with a neighbor
            in both directions it is considered an undirected graph.
            A return of &#34;False&#34; here could mean an undirected graph, or
            a &#34;broken&#34; graph, not all edges are checked in that case.

            Returns
            -------
            bool
                True if there are only single connections between two
                connected nodes, False otherwise.
                False does **NOT** directly mean that this is a correct
                undirected graph! 
        &#34;&#34;&#34;
        for n in self.nodes.values():
            for c in n.children.values():
                if c in n.parents:
                    return False
        return True
            
    def to_undirected(self) -&gt; Graph:
        &#34;&#34;&#34;
            Returns an undirected copy this graph. Sine this implementation
            does not really specify edge directions, we consider a bidrectional
            graph as undirected!
            
            Returns
            -------
            Graph
                An undirected copy of this graph.
        &#34;&#34;&#34;
        res = self.copy()
        # if res.is_directed: # This could be a shortcut, but since False does not 
        # guarantee a correct undirected graph, it is safer this way
        for n in res.nodes.values():
            for p in n.parents.values():
                n.add_child(p)
                p.add_parent(n)
            for c in n.children.values():
                c.add_child(n)
                n.add_parent(c)
        return res</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="ccbase.networks.Graph.is_directed"><code class="name">var <span class="ident">is_directed</span> :Â bool</code></dt>
<dd>
<div class="desc"><p>A property checking if this graph is directed in the
sense that there is only a directed edge between any two
connected nodes. If any node is connected with a neighbor
in both directions it is considered an undirected graph.
A return of "False" here could mean an undirected graph, or
a "broken" graph, not all edges are checked in that case.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if there are only single connections between two
connected nodes, False otherwise.
False does <strong>NOT</strong> directly mean that this is a correct
undirected graph!</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_directed(self) -&gt; bool:
    &#34;&#34;&#34;
        A property checking if this graph is directed in the 
        sense that there is only a directed edge between any two
        connected nodes. If any node is connected with a neighbor
        in both directions it is considered an undirected graph.
        A return of &#34;False&#34; here could mean an undirected graph, or
        a &#34;broken&#34; graph, not all edges are checked in that case.

        Returns
        -------
        bool
            True if there are only single connections between two
            connected nodes, False otherwise.
            False does **NOT** directly mean that this is a correct
            undirected graph! 
    &#34;&#34;&#34;
    for n in self.nodes.values():
        for c in n.children.values():
            if c in n.parents:
                return False
    return True</code></pre>
</details>
</dd>
<dt id="ccbase.networks.Graph.num_nodes"><code class="name">var <span class="ident">num_nodes</span> :Â int</code></dt>
<dd>
<div class="desc"><p>Performs the same as "get_number_of_nodes" but as a property.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The total number of nodes in the graph.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def num_nodes(self) -&gt; int:
    &#34;&#34;&#34;
        Performs the same as &#34;get_number_of_nodes&#34; but as a property.

        Returns
        -------
        int
            The total number of nodes in the graph.
    &#34;&#34;&#34;
    return len(self.nodes)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ccbase.networks.Graph.add_edge"><code class="name flex">
<span>def <span class="ident">add_edge</span></span>(<span>self, node1:Â Union[str,Â Node], node2:Â Union[str,Â Node])</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a directed edge from node1 to node2. In this implementation, edges
are only implictly represented, via parent and child relations in the
nodes. One could alternatively explicitly represent edge objects that
connect nodes.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node1</code></strong> :&ensp;<code>String</code> or <code>Node</code></dt>
<dd>The name of the first node. The node object can also be used.</dd>
<dt><strong><code>node2</code></strong> :&ensp;<code>String</code> or <code>Node</code></dt>
<dd>The name of the second node. The node object can also be used.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>When either of the two nodes does not exist in the graph.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_edge(self, node1: Union[str, Node], node2: Union[str, Node]):
    &#34;&#34;&#34;
        Adds a directed edge from node1 to node2. In this implementation, edges
        are only implictly represented, via parent and child relations in the
        nodes. One could alternatively explicitly represent edge objects that
        connect nodes.
        
        Parameters
        ----------
        node1: String or Node
            The name of the first node. The node object can also be used.
        node2: String or Node
            The name of the second node. The node object can also be used.

        Raises
        ------
        ValueError
            When either of the two nodes does not exist in the graph.
    &#34;&#34;&#34;
    try:
        self.nodes[node1].add_child(self.nodes[node2])
        self.nodes[node2].add_parent(self.nodes[node1])
    except KeyError:
        raise ValueError(&#34;At least one of your specified nodes ({},{}) &#34; \
                         &#34;is not contained in the graph&#34;.format(node1, node2))</code></pre>
</details>
</dd>
<dt id="ccbase.networks.Graph.add_node"><code class="name flex">
<span>def <span class="ident">add_node</span></span>(<span>self, node:Â Union[str,Â Node])</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a node to the graph. Will first create a new node object
with the given name.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>String</code> or <code>Node</code></dt>
<dd>The name of the new node or the new node directly. In case
a string is passed, a new node will be created before adding it.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_node(self, node: Union[str, Node]):
    &#34;&#34;&#34;
        Adds a node to the graph. Will first create a new node object
        with the given name.
        
        Parameters
        ----------
        node: String or Node
            The name of the new node or the new node directly. In case
            a string is passed, a new node will be created before adding it.
    &#34;&#34;&#34;
    if node in self.nodes:
        raise ValueError(&#34;The graph already contains a node named {}&#34;.format(node))
    
    try:
        self.nodes[node.name] = node
    except AttributeError: #We check for an attribute, rather than a type.
        self.nodes[node] = Node(node)</code></pre>
</details>
</dd>
<dt id="ccbase.networks.Graph.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, deep=True) â€‘>Â <a title="ccbase.networks.Graph" href="#ccbase.networks.Graph">Graph</a></span>
</code></dt>
<dd>
<div class="desc"><p>Copies the current graph.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>deep</code></strong> :&ensp;<code>Bool</code></dt>
<dd>If true, a deep copy will be performed, i.e. all nodes are also
copied. In a shallow copy, both graph instances will contain the
same node references.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="ccbase.networks.Graph" href="#ccbase.networks.Graph">Graph</a></code></dt>
<dd>Creates a (deep) copy of this graph.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self, deep=True) -&gt; Graph:
    &#34;&#34;&#34;
        Copies the current graph.
        
        Parameters
        ----------
        deep: Bool
            If true, a deep copy will be performed, i.e. all nodes are also
            copied. In a shallow copy, both graph instances will contain the
            same node references.
        
        Returns
        -------
        Graph
            Creates a (deep) copy of this graph.
    &#34;&#34;&#34;
   
    if deep:
        return copy.deepcopy(self)
    else:
         return copy.copy(self)</code></pre>
</details>
</dd>
<dt id="ccbase.networks.Graph.get_ancestors"><code class="name flex">
<span>def <span class="ident">get_ancestors</span></span>(<span>self, node:Â Union[str,Â Node]) â€‘>Â List[<a title="ccbase.nodes.Node" href="nodes.html#ccbase.nodes.Node">Node</a>]</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>String</code> or <code>Node</code></dt>
<dd>The name of the node whose ancestors are queried.
The Node object itself can also be used.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>set</code></dt>
<dd>A set containing all ancestor nodes of the specified node.
Be careful that these are the actual node objects contained in
the graph, NOT copies!</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>When the graph does not contain the queried node.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ancestors(self, node: Union[str, Node]) -&gt; List[Node]:
    &#34;&#34;&#34;
        Parameters
        ----------
        node: String or Node
            The name of the node whose ancestors are queried.
            The Node object itself can also be used.
            
        Returns
        -------
        set
            A set containing all ancestor nodes of the specified node.
            Be careful that these are the actual node objects contained in
            the graph, NOT copies!

        Raises
        ------
        ValueError
            When the graph does not contain the queried node.
    &#34;&#34;&#34;
    if not node in self.nodes:
        raise ValueError(&#34;The graph does not contain a node called {}&#34;.format(node))
    def _add_parents(tmpNode):
        for p in tmpNode.parents.values():
            if p in res:
                continue
            res.add(p)
            _add_parents(p)
    res = set()
    _add_parents(self.nodes[node])
    return res</code></pre>
</details>
</dd>
<dt id="ccbase.networks.Graph.get_children"><code class="name flex">
<span>def <span class="ident">get_children</span></span>(<span>self, node:Â Union[str,Â Node]) â€‘>Â List[<a title="ccbase.nodes.Node" href="nodes.html#ccbase.nodes.Node">Node</a>]</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>String</code></dt>
<dd>The name of the node whose children are queried.
The Node object itself can also be used.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>A list containing all children nodes of the specified node.
Be careful that these are the actual node objects contained in
the graph, NOT copies!</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>When the graph does not contain the queried node.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_children(self, node: Union[str, Node]) -&gt; List[Node]:
    &#34;&#34;&#34;
        Parameters
        ----------
        node: String
            The name of the node whose children are queried.
            The Node object itself can also be used.
            
        Returns
        -------
        list
            A list containing all children nodes of the specified node.
            Be careful that these are the actual node objects contained in
            the graph, NOT copies!

        Raises
        ------
        ValueError
            When the graph does not contain the queried node.
    &#34;&#34;&#34;
    try:
        return list(self.nodes[node].children.values())
    except KeyError:
        raise ValueError(&#34;The graph does not contain a node called {}&#34;.format(node)) </code></pre>
</details>
</dd>
<dt id="ccbase.networks.Graph.get_descendants"><code class="name flex">
<span>def <span class="ident">get_descendants</span></span>(<span>self, node:Â Union[str,Â Node]) â€‘>Â List[<a title="ccbase.nodes.Node" href="nodes.html#ccbase.nodes.Node">Node</a>]</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>String</code> or <code><a title="ccbase.nodes.Node" href="nodes.html#ccbase.nodes.Node">Node</a></code></dt>
<dd>The name of the node whose descendants are queried.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>set</code></dt>
<dd>A set containing all descendant nodes of the specified node.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_descendants(self, node: Union[str, Node]) -&gt; List[Node]:
    &#34;&#34;&#34;
        Parameters
        ----------
        node: String or `ccbase.nodes.Node`
            The name of the node whose descendants are queried.
            
        Returns
        -------
        set
            A set containing all descendant nodes of the specified node.
    &#34;&#34;&#34;
    def _add_children(tmp_node):
        for p in tmp_node.children.values():
            if p in res:
                continue
            res.add(p)
            _add_children(p)
    res = set()
    _add_children(self.nodes[node])
    return res</code></pre>
</details>
</dd>
<dt id="ccbase.networks.Graph.get_number_of_nodes"><code class="name flex">
<span>def <span class="ident">get_number_of_nodes</span></span>(<span>self) â€‘>Â int</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>The total number of nodes in the graph.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_number_of_nodes(self) -&gt; int:
    &#34;&#34;&#34;
        Returns
        -------
        int
            The total number of nodes in the graph.
    &#34;&#34;&#34;
    return len(self.nodes)</code></pre>
</details>
</dd>
<dt id="ccbase.networks.Graph.get_parents"><code class="name flex">
<span>def <span class="ident">get_parents</span></span>(<span>self, node:Â Union[str,Â Node]) â€‘>Â List[<a title="ccbase.nodes.Node" href="nodes.html#ccbase.nodes.Node">Node</a>]</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>String</code> or <code>Node</code></dt>
<dd>The name of the node whose parents are queried.
The Node object itself can also be used.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>A list containing all parent nodes of the specified node.
Be careful that these are the actual node objects contained in
the graph, NOT copies!</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>When the graph does not contain the queried node.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_parents(self, node: Union[str, Node]) -&gt; List[Node]:
    &#34;&#34;&#34;
        Parameters
        ----------
        node: String or Node
            The name of the node whose parents are queried.
            The Node object itself can also be used.
            
        Returns
        -------
        list
            A list containing all parent nodes of the specified node.
            Be careful that these are the actual node objects contained in
            the graph, NOT copies!

        Raises
        ------
        ValueError
            When the graph does not contain the queried node.
    &#34;&#34;&#34;
    try:
        return list(self.nodes[node].parents.values())
    except KeyError:
        raise ValueError(&#34;The graph does not contain a node called {}&#34;.format(node))</code></pre>
</details>
</dd>
<dt id="ccbase.networks.Graph.is_acyclic"><code class="name flex">
<span>def <span class="ident">is_acyclic</span></span>(<span>self) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Computes whether or not this graph is acyclic.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if there are no cycles within the provided graph, False otherwise.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_acyclic(self) -&gt; bool:
    &#34;&#34;&#34;
        Computes whether or not this graph is acyclic.
    
        Returns
        ----------
        bool
            True if there are no cycles within the provided graph, False otherwise.
    &#34;&#34;&#34;
    def _cyclic(node):
        &#34;&#34;&#34;
            Private helper function to check if a node is cyclic.
            
            This basically implements a marking/painting algorithm going over all
            nodes and marking them according to 0=not yet visited, 1=currently
            active and 2=done, but with the short circuit of breaking as soon
            as we find a loop (i.e. we meet another node, that is currently
            active).
        &#34;&#34;&#34;
        if statusMap[node] == 2:
            return False
        if statusMap[node] == 1:
            return True
        statusMap[node] = 1
        for n in node.children.values():
            if _cyclic(n):
                return True
        statusMap[node] = 2
        return False
    
    statusMap = {}
    for n in self.nodes.values():
        statusMap[n] = 0
    for n in self.nodes.values():
        if _cyclic(n):
            return False

    return True</code></pre>
</details>
</dd>
<dt id="ccbase.networks.Graph.is_ancestor"><code class="name flex">
<span>def <span class="ident">is_ancestor</span></span>(<span>self, node_a:Â Union[str,Â Node], node_b:Â Union[str,Â Node]) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if node_a is an ancestor of node_b.
Should also work in cyclic graphs!</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node_a</code></strong> :&ensp;<code>String</code></dt>
<dd>The name of the potential ancestor node.</dd>
<dt><strong><code>node_b</code></strong> :&ensp;<code>String</code></dt>
<dd>The name of the potential descendant node.</dd>
</dl>
<h2 id="returns">Returns</h2>
<pre><code>bool
True if node_a is an ancestor of node_b, False otherwise.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_ancestor(self, node_a: Union[str, Node], node_b: Union[str, Node]) -&gt; bool:
    &#34;&#34;&#34;
        Checks if node_a is an ancestor of node_b. 
        Should also work in cyclic graphs!

        Parameters
        ----------
        node_a: String
            The name of the potential ancestor node.
        node_b: String
            The name of the potential descendant node.

        Returns
        -------
            bool
            True if node_a is an ancestor of node_b, False otherwise.
    &#34;&#34;&#34;
    return node_a in self.get_ancestors(node_b)</code></pre>
</details>
</dd>
<dt id="ccbase.networks.Graph.is_descendant"><code class="name flex">
<span>def <span class="ident">is_descendant</span></span>(<span>self, node_a:Â Union[str,Â Node], node_b:Â Union[str,Â Node]) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if node_a is a descendant of node_b.
Should also work in cyclic graphs!</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node_a</code></strong> :&ensp;<code>String</code></dt>
<dd>The name of the potential descendant node.</dd>
<dt><strong><code>node_b</code></strong> :&ensp;<code>String</code></dt>
<dd>The name of the potential ancestor node.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if node_a is a descendant of node_b, False otherwise.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_descendant(self, node_a: Union[str, Node], node_b: Union[str, Node]) -&gt; bool:
    &#34;&#34;&#34;
        Checks if node_a is a descendant of node_b. 
        Should also work in cyclic graphs!

        Parameters
        ----------
        node_a: String
            The name of the potential descendant node.
        node_b: String
            The name of the potential ancestor node.

        Returns
        -------
        bool
            True if node_a is a descendant of node_b, False otherwise.
    &#34;&#34;&#34;
    return node_b in self.get_ancestors(node_a)</code></pre>
</details>
</dd>
<dt id="ccbase.networks.Graph.remove_edge"><code class="name flex">
<span>def <span class="ident">remove_edge</span></span>(<span>self, node1:Â Union[str,Â Node], node2:Â Union[str,Â Node])</span>
</code></dt>
<dd>
<div class="desc"><p>Removes an edge from node1 to node2, if it exists. Ignores incorrect
edges.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node1</code></strong> :&ensp;<code>String</code> or <code>Node</code></dt>
<dd>The name of the first node. The node object can also be used.</dd>
<dt><strong><code>node2</code></strong> :&ensp;<code>String</code> or <code>Node</code></dt>
<dd>The name of the second node. The node object can also be used.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>When either of the two nodes does not exist in the graph.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_edge(self, node1: Union[str, Node], node2: Union[str, Node]):
    &#34;&#34;&#34;
        Removes an edge from node1 to node2, if it exists. Ignores incorrect
        edges.
        
        Parameters
        ----------
        node1: String or Node
            The name of the first node. The node object can also be used.
        node2: String or Node
            The name of the second node. The node object can also be used.
        Raises
        ------
        ValueError
            When either of the two nodes does not exist in the graph.
    &#34;&#34;&#34;
    try:
        self.nodes[node1].remove_child(self.nodes[node2])
        self.nodes[node2].remove_parent(self.nodes[node1])
    except KeyError:
        raise ValueError(&#34;At least one of your specified nodes ({},{}) &#34; \
                         &#34;is not contained in the graph&#34;.format(node1, node2))</code></pre>
</details>
</dd>
<dt id="ccbase.networks.Graph.remove_node"><code class="name flex">
<span>def <span class="ident">remove_node</span></span>(<span>self, node:Â Union[str,Â Node])</span>
</code></dt>
<dd>
<div class="desc"><p>Removes the node with the given name from the graph.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>String</code> or <code>Node</code></dt>
<dd>The name of the new node or the node object itself.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_node(self, node: Union[str, Node]):
    &#34;&#34;&#34;
        Removes the node with the given name from the graph.
        
        Parameters
        ----------
        node: String or Node
            The name of the new node or the node object itself.
    &#34;&#34;&#34;
    if not node in self.nodes:
        raise ValueError(&#34;The graph does not contain a node named {}&#34;.format(node))
    
    self.nodes[node].destroy()
    del self.nodes[node]</code></pre>
</details>
</dd>
<dt id="ccbase.networks.Graph.to_undirected"><code class="name flex">
<span>def <span class="ident">to_undirected</span></span>(<span>self) â€‘>Â <a title="ccbase.networks.Graph" href="#ccbase.networks.Graph">Graph</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns an undirected copy this graph. Sine this implementation
does not really specify edge directions, we consider a bidrectional
graph as undirected!</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="ccbase.networks.Graph" href="#ccbase.networks.Graph">Graph</a></code></dt>
<dd>An undirected copy of this graph.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_undirected(self) -&gt; Graph:
    &#34;&#34;&#34;
        Returns an undirected copy this graph. Sine this implementation
        does not really specify edge directions, we consider a bidrectional
        graph as undirected!
        
        Returns
        -------
        Graph
            An undirected copy of this graph.
    &#34;&#34;&#34;
    res = self.copy()
    # if res.is_directed: # This could be a shortcut, but since False does not 
    # guarantee a correct undirected graph, it is safer this way
    for n in res.nodes.values():
        for p in n.parents.values():
            n.add_child(p)
            p.add_parent(n)
        for c in n.children.values():
            c.add_child(n)
            n.add_parent(c)
    return res</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ccbase" href="index.html">ccbase</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ccbase.networks.Graph" href="#ccbase.networks.Graph">Graph</a></code></h4>
<ul class="two-column">
<li><code><a title="ccbase.networks.Graph.add_edge" href="#ccbase.networks.Graph.add_edge">add_edge</a></code></li>
<li><code><a title="ccbase.networks.Graph.add_node" href="#ccbase.networks.Graph.add_node">add_node</a></code></li>
<li><code><a title="ccbase.networks.Graph.copy" href="#ccbase.networks.Graph.copy">copy</a></code></li>
<li><code><a title="ccbase.networks.Graph.get_ancestors" href="#ccbase.networks.Graph.get_ancestors">get_ancestors</a></code></li>
<li><code><a title="ccbase.networks.Graph.get_children" href="#ccbase.networks.Graph.get_children">get_children</a></code></li>
<li><code><a title="ccbase.networks.Graph.get_descendants" href="#ccbase.networks.Graph.get_descendants">get_descendants</a></code></li>
<li><code><a title="ccbase.networks.Graph.get_number_of_nodes" href="#ccbase.networks.Graph.get_number_of_nodes">get_number_of_nodes</a></code></li>
<li><code><a title="ccbase.networks.Graph.get_parents" href="#ccbase.networks.Graph.get_parents">get_parents</a></code></li>
<li><code><a title="ccbase.networks.Graph.is_acyclic" href="#ccbase.networks.Graph.is_acyclic">is_acyclic</a></code></li>
<li><code><a title="ccbase.networks.Graph.is_ancestor" href="#ccbase.networks.Graph.is_ancestor">is_ancestor</a></code></li>
<li><code><a title="ccbase.networks.Graph.is_descendant" href="#ccbase.networks.Graph.is_descendant">is_descendant</a></code></li>
<li><code><a title="ccbase.networks.Graph.is_directed" href="#ccbase.networks.Graph.is_directed">is_directed</a></code></li>
<li><code><a title="ccbase.networks.Graph.num_nodes" href="#ccbase.networks.Graph.num_nodes">num_nodes</a></code></li>
<li><code><a title="ccbase.networks.Graph.remove_edge" href="#ccbase.networks.Graph.remove_edge">remove_edge</a></code></li>
<li><code><a title="ccbase.networks.Graph.remove_node" href="#ccbase.networks.Graph.remove_node">remove_node</a></code></li>
<li><code><a title="ccbase.networks.Graph.to_undirected" href="#ccbase.networks.Graph.to_undirected">to_undirected</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>